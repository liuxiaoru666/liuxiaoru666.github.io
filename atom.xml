<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘晓儒个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-22T14:52:26.872Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>刘晓儒</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS-WEB-API知识点梳理</title>
    <link href="http://yoursite.com/2019/08/22/JS-WEB-API%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    <id>http://yoursite.com/2019/08/22/JS-WEB-API知识点梳理/</id>
    <published>2019-08-22T14:52:10.000Z</published>
    <updated>2019-08-22T14:52:26.872Z</updated>
    
    <content type="html"><![CDATA[<p>除 ES 基础之外，Web 前端经常会用到一些跟浏览器相关的 API，接下来我们一起梳理一下。</p><h2 id="知识点梳理"><a href="#知识点梳理" class="headerlink" title="知识点梳理"></a>知识点梳理</h2><ul><li>BOM 操作</li><li>DOM 操作</li><li>事件绑定</li><li>Ajax</li><li>存储</li></ul><hr><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>BOM（浏览器对象模型）是浏览器本身的一些信息的设置和获取，例如获取浏览器的宽度、高度，设置让浏览器跳转到哪个地址。</p><ul><li><code>navigator</code></li><li><code>screen</code></li><li><code>location</code></li><li><code>history</code></li></ul><p>这些对象就是一堆非常简单粗暴的 API，没任何技术含量，讲起来一点意思都没有，大家去 MDN 或者 w3school 这种网站一查就都明白了。面试的时候，面试官基本不会出太多这方面的题目，因为只要基础知识过关了，这些 API 即便你记不住，上网一查也都知道了。下面列举一下常用功能的代码示例</p><p>获取浏览器特性（即俗称的<code>UA</code>）然后识别客户端，例如判断是不是 Chrome 浏览器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var ua = navigator.userAgent</span><br><span class="line">var isChrome = ua.indexOf(&apos;Chrome&apos;)</span><br><span class="line">console.log(isChrome)</span><br></pre></td></tr></table></figure><p>获取屏幕的宽度和高度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(screen.width)</span><br><span class="line">console.log(screen.height)</span><br></pre></td></tr></table></figure><p>获取网址、协议、path、参数、hash 等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 例如当前网址是 https://juejin.im/timeline/frontend?a=10&amp;b=10#some</span><br><span class="line">console.log(location.href)  // https://juejin.im/timeline/frontend?a=10&amp;b=10#some</span><br><span class="line">console.log(location.protocol) // https:</span><br><span class="line">console.log(location.pathname) // /timeline/frontend</span><br><span class="line">console.log(location.search) // ?a=10&amp;b=10</span><br><span class="line">console.log(location.hash) // #some</span><br></pre></td></tr></table></figure><p>另外，还有调用浏览器的前进、后退功能等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">history.back()</span><br><span class="line">history.forward()</span><br></pre></td></tr></table></figure><hr><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><blockquote><p>题目：DOM 和 HTML 区别和联系</p></blockquote><h3 id="什么是-DOM"><a href="#什么是-DOM" class="headerlink" title="什么是 DOM"></a>什么是 DOM</h3><p>讲 DOM 先从 HTML 讲起，讲 HTML 先从 XML 讲起。XML 是一种可扩展的标记语言，所谓可扩展就是它可以描述任何结构化的数据，它是一棵树！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">  &lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">  &lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">  &lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">  &lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt;</span><br><span class="line">  &lt;other&gt;</span><br><span class="line">    &lt;a&gt;&lt;/a&gt;</span><br><span class="line">    &lt;b&gt;&lt;/b&gt;</span><br><span class="line">  &lt;/other&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure><p>HTML 是一个有既定标签标准的 XML 格式，标签的名字、层级关系和属性，都被标准化（否则浏览器无法解析）。同样，它也是一棵树。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;this is p&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>我们开发完的 HTML 代码会保存到一个文档中（一般以<code>.html</code>或者<code>.htm</code>结尾），文档放在服务器上，浏览器请求服务器，这个文档被返回。因此，最终浏览器拿到的是一个文档而已，文档的内容就是 HTML 格式的代码。</p><p>但是浏览器要把这个文档中的 HTML 按照标准渲染成一个页面，此时浏览器就需要将这堆代码处理成自己能理解的东西，也得处理成 JS 能理解的东西，因为还得允许 JS 修改页面内容呢。</p><p>基于以上需求，浏览器就需要把 HTML 转变成 DOM，HTML 是一棵树，DOM 也是一棵树。对 DOM 的理解，可以暂时先抛开浏览器的内部因素，先从 JS 着手，即可以认为 DOM 就是 JS 能识别的 HTML 结构，一个普通的 JS 对象或者数组。</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/23/161c1050cf00d5bd?w=2102&h=1612&f=png&s=806057" alt="DOM图示"></p><h3 id="获取-DOM-节点"><a href="#获取-DOM-节点" class="headerlink" title="获取 DOM 节点"></a>获取 DOM 节点</h3><p>最常用的 DOM API 就是获取节点，其中常用的获取方法如下面代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 通过 id 获取</span><br><span class="line">var div1 = document.getElementById(&apos;div1&apos;) // 元素</span><br><span class="line"></span><br><span class="line">// 通过 tagname 获取</span><br><span class="line">var divList = document.getElementsByTagName(&apos;div&apos;)  // 集合</span><br><span class="line">console.log(divList.length)</span><br><span class="line">console.log(divList[0])</span><br><span class="line"></span><br><span class="line">// 通过 class 获取</span><br><span class="line">var containerList = document.getElementsByClassName(&apos;container&apos;) // 集合</span><br><span class="line"></span><br><span class="line">// 通过 CSS 选择器获取</span><br><span class="line">var pList = document.querySelectorAll(&apos;p&apos;) // 集合</span><br></pre></td></tr></table></figure><blockquote><p>题目：property 和 attribute 的区别是什么？</p></blockquote><h3 id="property"><a href="#property" class="headerlink" title="property"></a>property</h3><p>DOM 节点就是一个 JS 对象，它符合之前讲述的对象的特征 —— 可扩展属性，因为 DOM 节点本质上也是一个 JS 对象。因此，如下代码所示，<code>p</code>可以有<code>style</code>属性，有<code>className</code> <code>nodeName</code> <code>nodeType</code>属性。注意，<strong>这些都是 JS 范畴的属性，符合 JS 语法标准的</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var pList = document.querySelectorAll(&apos;p&apos;)</span><br><span class="line">var p = pList[0]</span><br><span class="line">console.log(p.style.width)  // 获取样式</span><br><span class="line">p.style.width = &apos;100px&apos;  // 修改样式</span><br><span class="line">console.log(p.className)  // 获取 class</span><br><span class="line">p.className = &apos;p1&apos;  // 修改 class</span><br><span class="line"></span><br><span class="line">// 获取 nodeName 和 nodeType</span><br><span class="line">console.log(p.nodeName)</span><br><span class="line">console.log(p.nodeType)</span><br></pre></td></tr></table></figure><h3 id="attribute"><a href="#attribute" class="headerlink" title="attribute"></a>attribute</h3><p>property 的获取和修改，是直接改变 JS 对象，而 attribute 是直接改变 HTML 的属性，两种有很大的区别。attribute 就是对 HTML 属性的 get 和 set，和 DOM 节点的 JS 范畴的 property 没有关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var pList = document.querySelectorAll(&apos;p&apos;)</span><br><span class="line">var p = pList[0]</span><br><span class="line">p.getAttribute(&apos;data-name&apos;)</span><br><span class="line">p.setAttribute(&apos;data-name&apos;, &apos;juejin&apos;)</span><br><span class="line">p.getAttribute(&apos;style&apos;)</span><br><span class="line">p.setAttribute(&apos;style&apos;, &apos;font-size:30px;&apos;)</span><br></pre></td></tr></table></figure><p>而且，get 和 set attribute 时，还会触发 DOM 的查询或者重绘、重排，频繁操作会影响页面性能。</p><blockquote><p>题目：DOM 操作的基本 API 有哪些？</p></blockquote><h3 id="DOM-树操作"><a href="#DOM-树操作" class="headerlink" title="DOM 树操作"></a>DOM 树操作</h3><p>新增节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var div1 = document.getElementById(&apos;div1&apos;)</span><br><span class="line"></span><br><span class="line">// 添加新节点</span><br><span class="line">var p1 = document.createElement(&apos;p&apos;)</span><br><span class="line">p1.innerHTML = &apos;this is p1&apos;</span><br><span class="line">div1.appendChild(p1) // 添加新创建的元素</span><br><span class="line"></span><br><span class="line">// 移动已有节点。注意，这里是“移动”，并不是拷贝</span><br><span class="line">var p2 = document.getElementById(&apos;p2&apos;)</span><br><span class="line">div1.appendChild(p2)</span><br></pre></td></tr></table></figure><p>获取父元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var div1 = document.getElementById(&apos;div1&apos;)</span><br><span class="line">var parent = div1.parentElement</span><br></pre></td></tr></table></figure><p>获取子元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var div1 = document.getElementById(&apos;div1&apos;)</span><br><span class="line">var child = div1.childNodes</span><br></pre></td></tr></table></figure><p>删除节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var div1 = document.getElementById(&apos;div1&apos;)</span><br><span class="line">var child = div1.childNodes</span><br><span class="line">div1.removeChild(child[0])</span><br></pre></td></tr></table></figure><p>还有其他操作的API，例如获取前一个节点、获取后一个节点等，但是面试过程中经常考到的就是上面几个。</p><hr><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>普通的事件绑定写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(&apos;btn1&apos;)</span><br><span class="line">btn.addEventListener(&apos;click&apos;, function (event) &#123;</span><br><span class="line">    // event.preventDefault() // 阻止默认行为</span><br><span class="line">    // event.stopPropagation() // 阻止冒泡</span><br><span class="line">    console.log(&apos;clicked&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>为了编写简单的事件绑定，可以编写通用的事件绑定函数。这里虽然比较简单，但是会随着后文的讲解，来继续完善和丰富这个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 通用的事件绑定函数</span><br><span class="line">function bindEvent(elem, type, fn) &#123;</span><br><span class="line">    elem.addEventListener(type, fn)</span><br><span class="line">&#125;</span><br><span class="line">var a = document.getElementById(&apos;link1&apos;)</span><br><span class="line">// 写起来更加简单了</span><br><span class="line">bindEvent(a, &apos;click&apos;, function(e) &#123;</span><br><span class="line">    e.preventDefault() // 阻止默认行为</span><br><span class="line">    alert(&apos;clicked&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最后，<strong>如果面试被问到 IE 低版本兼容性问题，我劝你果断放弃这份工作机会</strong>。现在互联网流量都在 App 上， IE 占比越来越少，再去为 IE 浪费青春不值得，要尽量去做 App 相关的工作。</p><blockquote><p>题目：什么是事件冒泡？</p></blockquote><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;div1&quot;&gt;</span><br><span class="line">        &lt;p id=&quot;p1&quot;&gt;激活&lt;/p&gt;</span><br><span class="line">        &lt;p id=&quot;p2&quot;&gt;取消&lt;/p&gt;</span><br><span class="line">        &lt;p id=&quot;p3&quot;&gt;取消&lt;/p&gt;</span><br><span class="line">        &lt;p id=&quot;p4&quot;&gt;取消&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;div2&quot;&gt;</span><br><span class="line">        &lt;p id=&quot;p5&quot;&gt;取消&lt;/p&gt;</span><br><span class="line">        &lt;p id=&quot;p6&quot;&gt;取消&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>对于以上 HTML 代码结构，要求点击<code>p1</code>时候进入激活状态，点击其他任何<code>&lt;p&gt;</code>都取消激活状态，如何实现？代码如下，注意看注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var body = document.body</span><br><span class="line">bindEvent(body, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    // 所有 p 的点击都会冒泡到 body 上，因为 DOM 结构中 body 是 p 的上级节点，事件会沿着 DOM 树向上冒泡</span><br><span class="line">    alert(&apos;取消&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var p1 = document.getElementById(&apos;p1&apos;)</span><br><span class="line">bindEvent(p1, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    e.stopPropagation() // 阻止冒泡</span><br><span class="line">    alert(&apos;激活&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果我们在<code>p1</code> <code>div1</code> <code>body</code>中都绑定了事件，它是会根据 DOM 的结构来冒泡，从下到上挨个执行的。但是我们使用<code>e.stopPropagation()</code>就可以阻止冒泡</p><blockquote><p>题目：如何使用事件代理？有何好处？</p></blockquote><h3 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h3><p>我们设定一种场景，如下代码，一个<code>&lt;div&gt;</code>中包含了若干个<code>&lt;a&gt;</code>，而且还能继续增加。那如何快捷方便地为所有<code>&lt;a&gt;</code>绑定事件呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;div1&quot;&gt;</span><br><span class="line">    &lt;a href=&quot;#&quot;&gt;a1&lt;/a&gt;</span><br><span class="line">    &lt;a href=&quot;#&quot;&gt;a2&lt;/a&gt;</span><br><span class="line">    &lt;a href=&quot;#&quot;&gt;a3&lt;/a&gt;</span><br><span class="line">    &lt;a href=&quot;#&quot;&gt;a4&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;button&gt;点击增加一个 a 标签&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>这里就会用到事件代理。我们要监听<code>&lt;a&gt;</code>的事件，但要把具体的事件绑定到<code>&lt;div&gt;</code>上，然后看事件的触发点是不是<code>&lt;a&gt;</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var div1 = document.getElementById(&apos;div1&apos;)</span><br><span class="line">div1.addEventListener(&apos;click&apos;, function (e) &#123;</span><br><span class="line">    // e.target 可以监听到触发点击事件的元素是哪一个</span><br><span class="line">    var target = e.target</span><br><span class="line">    if (e.nodeName === &apos;A&apos;) &#123;</span><br><span class="line">        // 点击的是 &lt;a&gt; 元素</span><br><span class="line">        alert(target.innerHTML)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们现在完善一下之前写的通用事件绑定函数，加上事件代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function bindEvent(elem, type, selector, fn) &#123;</span><br><span class="line">    // 这样处理，可接收两种调用方式 bindEvent(div1, &apos;click&apos;, &apos;a&apos;, function () &#123;...&#125;) 和 bindEvent(div1, &apos;click&apos;, function () &#123;...&#125;) 这两种</span><br><span class="line">    if (fn == null) &#123;</span><br><span class="line">        fn = selector</span><br><span class="line">        selector = null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 绑定事件</span><br><span class="line">    elem.addEventListener(type, function (e) &#123;</span><br><span class="line">        var target</span><br><span class="line">        if (selector) &#123;</span><br><span class="line">            // 有 selector 说明需要做事件代理</span><br><span class="line">            // 获取触发时间的元素，即 e.target</span><br><span class="line">            target = e.target</span><br><span class="line">            // 看是否符合 selector 这个条件</span><br><span class="line">            if (target.matches(selector)) &#123;</span><br><span class="line">                fn.call(target, e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 无 selector ，说明不需要事件代理</span><br><span class="line">            fn(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这样使用，简单很多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 使用代理，bindEvent 多一个 &apos;a&apos; 参数</span><br><span class="line">var div1 = document.getElementById(&apos;div1&apos;)</span><br><span class="line">bindEvent(div1, &apos;click&apos;, &apos;a&apos;, function (e) &#123;</span><br><span class="line">    console.log(this.innerHTML)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 不使用代理</span><br><span class="line">var a = document.getElementById(&apos;a1&apos;)</span><br><span class="line">bindEvent(div1, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(a.innerHTML)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最后，使用代理的优点如下：</p><ul><li>使代码简洁</li><li>减少浏览器的内存占用</li></ul><hr><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h3><blockquote><p>题目：手写 XMLHttpRequest 不借助任何库</p></blockquote><p>这是很多奇葩的、个性的面试官经常用的手段。这种考查方式存在很多争议，但是你不能完全说它是错误的，毕竟也是考查对最基础知识的掌握情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest()</span><br><span class="line">xhr.onreadystatechange = function () &#123;</span><br><span class="line">    // 这里的函数异步执行，可参考之前 JS 基础中的异步模块</span><br><span class="line">    if (xhr.readyState == 4) &#123;</span><br><span class="line">        if (xhr.status == 200) &#123;</span><br><span class="line">            alert(xhr.responseText)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(&quot;GET&quot;, &quot;/api&quot;, false)</span><br><span class="line">xhr.send(null)</span><br></pre></td></tr></table></figure><p>当然，使用 jQuery、Zepto 或 Fetch 等库来写就更加简单了，这里不再赘述。</p><h3 id="状态码说明"><a href="#状态码说明" class="headerlink" title="状态码说明"></a>状态码说明</h3><p>上述代码中，有两处状态码需要说明。<code>xhr.readyState</code>是浏览器判断请求过程中各个阶段的，<code>xhr.status</code>是 HTTP 协议中规定的不同结果的返回状态说明。</p><p><code>xhr.readyState</code>的状态码说明：</p><ul><li>0 -代理被创建，但尚未调用 <code>open()</code> 方法。</li><li>1 -<code>open()</code> 方法已经被调用。</li><li>2 -<code>send()</code> 方法已经被调用，并且头部和状态已经可获得。</li><li>3 -下载中， <code>responseText</code> 属性已经包含部分数据。</li><li>4 -下载操作已完成</li></ul><blockquote><p>题目：HTTP 协议中，response 的状态码，常见的有哪些？</p></blockquote><p><code>xhr.status</code>即 HTTP 状态码，有 <code>2xx</code> <code>3xx</code> <code>4xx</code> <code>5xx</code> 这几种，比较常用的有以下几种：</p><ul><li><code>200</code> 正常</li><li><code>3xx</code><ul><li><code>301</code> 永久重定向。如<code>http://xxx.com</code>这个 GET 请求（最后没有<code>/</code>），就会被<code>301</code>到<code>http://xxx.com/</code>（最后是<code>/</code>）</li><li><code>302</code> 临时重定向。临时的，不是永久的</li><li><code>304</code> 资源找到但是不符合请求条件，不会返回任何主体。如发送 GET 请求时，head 中有<code>If-Modified-Since: xxx</code>（要求返回更新时间是<code>xxx</code>时间之后的资源），如果此时服务器 端资源未更新，则会返回<code>304</code>，即不符合要求</li></ul></li><li><code>404</code> 找不到资源</li><li><code>5xx</code> 服务器端出错了</li></ul><p>看完要明白，为何上述代码中要同时满足<code>xhr.readyState == 4</code>和<code>xhr.status == 200</code>。</p><h3 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h3><p>目前已经有一个获取 HTTP 请求更加方便的 API：<code>Fetch</code>，通过<code>Fetch</code>提供的<code>fetch()</code>这个全局函数方法可以很简单地发起异步请求，并且支持<code>Promise</code>的回调。但是 Fetch API 是比较新的 API，具体使用的时候还需要查查 <a href="https://caniuse.com/" target="_blank" rel="noopener">caniuse</a>，看下其浏览器兼容情况。</p><p>看一个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;some/api/data.json&apos;, &#123;</span><br><span class="line">  method:&apos;POST&apos;, //请求类型 GET、POST</span><br><span class="line">  headers:&#123;&#125;, // 请求的头信息，形式为 Headers 对象或 ByteString</span><br><span class="line">  body:&#123;&#125;, //请求发送的数据 blob、BufferSource、FormData、URLSearchParams（get 或head 方法中不能包含 body）</span><br><span class="line">  mode:&apos;&apos;, //请求的模式，是否跨域等，如 cors、 no-cors 或 same-origin</span><br><span class="line">  credentials:&apos;&apos;, //cookie 的跨域策略，如 omit、same-origin 或 include</span><br><span class="line">  cache:&apos;&apos;, //请求的 cache 模式: default、no-store、reload、no-cache、 force-cache 或 only-if-cached</span><br><span class="line">&#125;).then(function(response) &#123; ... &#125;);</span><br></pre></td></tr></table></figure><p><code>Fetch</code> 支持<code>headers</code>定义，通过<code>headers</code>自定义可以方便地实现多种请求方法（ PUT、GET、POST 等）、请求头（包括跨域）和<code>cache</code>策略等；除此之外还支持 response（返回数据）多种类型，比如支持二进制文件、字符串和<code>formData</code>等。</p><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><blockquote><p>题目：如何实现跨域？</p></blockquote><p>浏览器中有 <strong>同源策略</strong> ，即一个域下的页面中，无法通过 Ajax 获取到其他域的接口。例如有一个接口<code>http://m.juejin.com/course/ajaxcourserecom?cid=459</code>，你自己的一个页面<code>http://www.yourname.com/page1.html</code>中的 Ajax 无法获取这个接口。这正是命中了“同源策略”。如果浏览器哪些地方忽略了同源策略，那就是浏览器的安全漏洞，需要紧急修复。</p><p>url 哪些地方不同算作跨域？</p><ul><li>协议</li><li>域名</li><li>端口</li></ul><p>但是 HTML 中几个标签能逃避过同源策略——<code>&lt;script src=&quot;xxx&quot;&gt;</code>、<code>&lt;img src=&quot;xxxx&quot;/&gt;</code>、<code>&lt;link href=&quot;xxxx&quot;&gt;</code>，这三个标签的<code>src/href</code>可以加载其他域的资源，不受同源策略限制。</p><p>因此，这使得这三个标签可以做一些特殊的事情。</p><ul><li><code>&lt;img&gt;</code>可以做打点统计，因为统计方并不一定是同域的，在讲解 JS 基础知识异步的时候有过代码示例。除了能跨域之外，<code>&lt;img&gt;</code>几乎没有浏览器兼容问题，它是一个非常古老的标签。</li><li><code>&lt;script&gt;</code>和<code>&lt;link&gt;</code>可以使用 CDN，CDN 基本都是其他域的链接。</li><li>另外<code>&lt;script&gt;</code>还可以实现 JSONP，能获取其他域接口的信息，接下来马上讲解。</li></ul><p>但是请注意，所有的跨域请求方式，最终都需要信息提供方来做出相应的支持和改动，也就是要经过信息提供方的同意才行，否则接收方是无法得到它们的信息的，浏览器是不允许的。</p><h3 id="解决跨域-JSONP"><a href="#解决跨域-JSONP" class="headerlink" title="解决跨域 - JSONP"></a>解决跨域 - JSONP</h3><p>首先，有一个概念你要明白，例如访问<code>http://coding.m.juejin.com/classindex.html</code>的时候，服务器端就一定有一个<code>classindex.html</code>文件吗？—— 不一定，服务器可以拿到这个请求，动态生成一个文件，然后返回。 同理，<code>&lt;script src=&quot;http://coding.m.juejin.com/api.js&quot;&gt;</code>也不一定加载一个服务器端的静态文件，服务器也可以动态生成文件并返回。OK，接下来正式开始。</p><p>例如我们的网站和掘金网，肯定不是一个域。我们需要掘金网提供一个接口，供我们来获取。首先，我们在自己的页面这样定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">window.callback = function (data) &#123;</span><br><span class="line">    // 这是我们跨域得到信息</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>然后掘金网给我提供了一个<code>http://coding.m.juejin.com/api.js</code>，内容如下（之前说过，服务器可动态生成内容）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback(&#123;x:100, y:200&#125;)</span><br></pre></td></tr></table></figure><p>最后我们在页面中加入<code>&lt;script src=&quot;http://coding.m.juejin.com/api.js&quot;&gt;&lt;/script&gt;</code>，那么这个js加载之后，就会执行内容，我们就得到内容了。</p><h3 id="解决跨域-服务器端设置-http-header"><a href="#解决跨域-服务器端设置-http-header" class="headerlink" title="解决跨域 - 服务器端设置 http header"></a>解决跨域 - 服务器端设置 http header</h3><p>这是需要在服务器端设置的，作为前端工程师我们不用详细掌握，但是要知道有这么个解决方案。而且，现在推崇的跨域解决方案是这一种，比 JSONP 简单许多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://m.juejin.com/&quot;);  // 第二个参数填写允许跨域的域名称，不建议直接写 &quot;*&quot;</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;);</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);</span><br><span class="line"></span><br><span class="line">// 接收跨域的cookie</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</span><br></pre></td></tr></table></figure><hr><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><blockquote><p>题目：cookie 和 localStorage 有何区别？</p></blockquote><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>cookie 本身不是用来做服务器端存储的（计算机领域有很多这种“狗拿耗子”的例子，例如 CSS 中的 float），它是设计用来在服务器和客户端进行信息传递的，因此我们的每个 HTTP 请求都带着 cookie。但是 cookie 也具备浏览器端存储的能力（例如记住用户名和密码），因此就被开发者用上了。</p><p>使用起来也非常简单，<code>document.cookie = ....</code>即可。</p><p>但是 cookie 有它致命的缺点：</p><ul><li>存储量太小，只有 4KB</li><li>所有 HTTP 请求都带着，会影响获取资源的效率</li><li>API 简单，需要封装才能用</li></ul><h3 id="localStorage-和-sessionStorage"><a href="#localStorage-和-sessionStorage" class="headerlink" title="localStorage 和 sessionStorage"></a>localStorage 和 sessionStorage</h3><p>后来，HTML5 标准就带来了<code>sessionStorage</code>和<code>localStorage</code>，先拿<code>localStorage</code>来说，它是专门为了浏览器端缓存而设计的。其优点有：</p><ul><li>存储量增大到 5MB</li><li>不会带到 HTTP 请求中</li><li>API 适用于数据存储 <code>localStorage.setItem(key, value)</code> <code>localStorage.getItem(key)</code></li></ul><p><code>sessionStorage</code>的区别就在于它是根据 session 过去时间而实现，而<code>localStorage</code>会永久有效，应用场景不同。例如，一些需要及时失效的重要信息放在<code>sessionStorage</code>中，一些不重要但是不经常设置的信息，放在<code>localStorage</code>中。</p><p>另外告诉大家一个小技巧，针对<code>localStorage.setItem</code>，使用时尽量加入到<code>try-catch</code>中，某些浏览器是禁用这个 API 的，要注意。</p><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本小节总结了 W3C 标准中 Web-API 部分，面试中常考的知识点，这些也是日常开发中最常用的 API 和知识。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;除 ES 基础之外，Web 前端经常会用到一些跟浏览器相关的 API，接下来我们一起梳理一下。&lt;/p&gt;
&lt;h2 id=&quot;知识点梳理&quot;&gt;&lt;a href=&quot;#知识点梳理&quot; class=&quot;headerlink&quot; title=&quot;知识点梳理&quot;&gt;&lt;/a&gt;知识点梳理&lt;/h2&gt;&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
      <category term="知识点梳理" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>HTML,CSS知识点梳理</title>
    <link href="http://yoursite.com/2019/08/22/HTML-CSS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    <id>http://yoursite.com/2019/08/22/HTML-CSS知识点梳理/</id>
    <published>2019-08-22T14:46:54.000Z</published>
    <updated>2019-08-22T14:52:38.323Z</updated>
    
    <content type="html"><![CDATA[<p>CSS 和 HTML 是网页开发中布局相关的组成部分，涉及的内容比较多和杂乱，本小节重点介绍下常考的知识点。</p><h2 id="知识点梳理"><a href="#知识点梳理" class="headerlink" title="知识点梳理"></a>知识点梳理</h2><ul><li>选择器的权重和优先级</li><li>盒模型<ul><li>盒子大小计算</li><li>margin 的重叠计算</li></ul></li><li>浮动<code>float</code><ul><li>浮动布局概念</li><li>清理浮动</li></ul></li><li>定位<code>position</code><ul><li>文档流概念</li><li>定位分类</li><li>fixed 定位特点</li><li>绝对定位计算方式</li></ul></li><li><code>flex</code>布局</li><li>如何实现居中对齐？</li><li>理解语义化</li><li>CSS3 动画</li><li>重绘和回流</li></ul><hr><h2 id="选择器的权重和优先级"><a href="#选择器的权重和优先级" class="headerlink" title="选择器的权重和优先级"></a>选择器的权重和优先级</h2><p>CSS 选择器有很多，不同的选择器的权重和优先级不一样，对于一个元素，如果存在多个选择器，那么就需要根据权重来计算其优先级。</p><p>权重分为四级，分别是：</p><ol><li>代表内联样式，如<code>style=&quot;xxx&quot;</code>，权值为 1000；</li><li>代表 ID 选择器，如<code>#content</code>，权值为 100；</li><li>代表类、伪类和属性选择器，如<code>.content</code>、<code>:hover</code>、<code>[attribute]</code>，权值为 10；</li><li>代表元素选择器和伪元素选择器，如<code>div</code>、<code>p</code>，权值为 1。</li></ol><p><strong>需要注意的是：通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以他们的权值都为 0</strong>。 权重值大的选择器其优先级也高，相同权重的优先级又遵循后定义覆盖前面定义的情况。</p><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><h3 id="什么是“盒子”"><a href="#什么是“盒子”" class="headerlink" title="什么是“盒子”"></a>什么是“盒子”</h3><p>初学 CSS 的朋友，一开始学 CSS 基础知识的时候一定学过<code>padding</code> <code>border</code>和<code>margin</code>，即内边距、边框和外边距。它们三者就构成了一个“盒子”。就像我们收到的快递，本来买了一部小小的手机，收到的却是那么大一个盒子。因为手机白色的包装盒和手机机器之间有间隔层（内边距），手机白色盒子有厚度，虽然很薄（边框），盒子和快递箱子之间还有一层泡沫板（外边距）。这就是一个典型的盒子。</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/23/161c106628765b93?w=255&h=146&f=png&s=5774" alt></p><p>如上图，真正的内容就是这些文字，文字外围有 10px 的内边距，5px 的边框，10px 的外边距。看到盒子了吧？</p><blockquote><p>题目：盒子模型的宽度如何计算</p></blockquote><h3 id="固定宽度的盒子"><a href="#固定宽度的盒子" class="headerlink" title="固定宽度的盒子"></a>固定宽度的盒子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;padding:10px; border:5px solid blue; margin: 10px; width:300px;&quot;&gt;</span><br><span class="line">    之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》，</span><br><span class="line">    文章言简意赅的介绍的浏览器的工作过程，web前端</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/2/28/161db8f616b1aa63?w=832&h=228&f=png&s=34678" alt></p><p>如上图，得到网页效果之后，我们可以用截图工具来量一下文字内容的宽度。发现，文字内容的宽度刚好是 300px，也就是我们设置的宽度。</p><p>因此，<strong>在盒子模型中，我们设置的宽度都是内容宽度，不是整个盒子的宽度。而整个盒子的宽度是：（内容宽度 + <code>border</code>宽度 + <code>padding</code>宽度 + <code>margin</code>宽度）之和</strong>。这样我们改四个中的其中一个，都会导致盒子宽度的改变。这对我们来说不友好。</p><p>没关系，这个东西不友好早就有人发现了，而且已经解决，下文再说。</p><h3 id="充满父容器的盒子"><a href="#充满父容器的盒子" class="headerlink" title="充满父容器的盒子"></a>充满父容器的盒子</h3><p>默认情况下，<code>div</code>是<code>display:block</code>，宽度会充满整个父容器。如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;padding:10px; border:5px solid blue; margin: 10px; width:300px;&quot;&gt;</span><br><span class="line">    之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》，</span><br><span class="line">    文章言简意赅的介绍的浏览器的工作过程，web前端</span><br><span class="line">    之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》，</span><br><span class="line">    文章言简意赅的介绍的浏览器的工作过程，web前端</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/2/28/161db8f616fe21e3?w=1384&h=230&f=png&s=49446" alt></p><p>但是别忘记，这个 div 是个盒子模型，它的整个宽度包括（内容宽度 + <code>border</code>宽度 + <code>padding</code>宽度 + <code>margin</code>宽度），整个的宽度充满父容器。</p><p>问题就在这里。如果父容器宽度不变，我们手动增大<code>margin</code>、<code>border</code>或<code>padding</code>其中一项的宽度值，都会导致内容宽度的减少。极端情况下，如果内容的宽度压缩到不能再压缩了（例如一个字的宽度），那么浏览器会强迫增加父容器的宽度。这可不是我们想要看到的。</p><h3 id="包裹内容的盒子"><a href="#包裹内容的盒子" class="headerlink" title="包裹内容的盒子"></a>包裹内容的盒子</h3><p>这种情况下比较简单，内容的宽度按照内容计算，盒子的宽度将在内容宽度的基础上再增加（<code>padding</code>宽度 + <code>border</code>宽度 + <code>margin</code>宽度）之和。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;padding:10px; border:5px solid blue; margin: 10px; width:300px;&quot;&gt;</span><br><span class="line">    之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/2/28/161db8f61768fdde?w=1384&h=172&f=png&s=21314" alt></p><h3 id="box-sizing-border-box"><a href="#box-sizing-border-box" class="headerlink" title="box-sizing:border-box"></a><code>box-sizing:border-box</code></h3><p>前面提到，为盒子模型设置宽度，结果只是设置了内容的宽度，这个不合理。如何解决这一问题？答案就是为盒子指定样式：<strong><code>box-sizing:border-box</code></strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;padding:10px; border:5px solid blue; margin: 10px; width:300px; box-sizing:border-box;&quot;&gt;</span><br><span class="line">    之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/2/28/161db8f617aff82e?w=798&h=524&f=png&s=88750" alt></p><p>上图中，为<code>div</code>设置了<code>box-sizing:border-box</code>之后，300px 的<strong>宽度是内容 + <code>padding</code> + 边框的宽度（不包括<code>margin</code>）</strong>，这样就比较符合我们的实际要求了。建议大家在为系统写 CSS 时候，第一个样式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    box-sizing:border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大名鼎鼎的 Bootstrap 也把<code>box-sizing:border-box</code>加入到它的<code>*</code>选择器中，我们为什么不这样做呢？</p><h3 id="纵向-margin-重叠"><a href="#纵向-margin-重叠" class="headerlink" title="纵向 margin 重叠"></a>纵向 margin 重叠</h3><p>这里提到 margin，就不得不提一下 margin 的这一特性——纵向重叠。如<code>&lt;p&gt;</code>的纵向 margin 是 16px，那么两个<code>&lt;p&gt;</code>之间纵向的距离是多少？—— 按常理来说应该是 16 + 16 = 32px，但是答案仍然是 16px。因为纵向的 margin 是会重叠的，如果两者不一样大的话，大的会把小的“吃掉”。</p><hr><h2 id="浮动float"><a href="#浮动float" class="headerlink" title="浮动float"></a>浮动<code>float</code></h2><p>float 用于网页布局比较多，使用起来也比较简单，这里总结了一些比较重要、需要注意的知识点，供大家参考。</p><h3 id="误解和误用"><a href="#误解和误用" class="headerlink" title="误解和误用"></a>误解和误用</h3><p>float 被设计出来的初衷是用于<strong>文字环绕效果</strong>，即一个图片一段文字，图片<code>float:left</code>之后，文字会环绕图片。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;img src=&quot;image/1.png&quot; style=&quot;float:left&quot;&gt;</span><br><span class="line">    一段文字一段文字一段文字一段文字一段文字一段文字一段文字一段文字一段文字</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>但是，后来大家发现结合<code>float + div</code>可以实现之前通过<code>table</code>实现的网页布局，因此就被“误用”于网页布局了。</p><blockquote><p>题目：为何 float 会导致父元素塌陷？</p></blockquote><h3 id="破坏性"><a href="#破坏性" class="headerlink" title="破坏性"></a>破坏性</h3><p><img src="https://user-gold-cdn.xitu.io/2018/2/23/161c106660020bd4?w=1024&h=224&f=png&s=73435" alt></p><p>float 的<strong>破坏性</strong> —— float 破坏了父标签的原本结构，使得父标签出现了坍塌现象。导致这一现象的最根本原因在于：<strong>被设置了 float 的元素会脱离文档流</strong>。其根本原因在于 float 的设计初衷是解决文字环绕图片的问题。大家要记住 float 的这个影响。</p><h3 id="包裹性"><a href="#包裹性" class="headerlink" title="包裹性"></a>包裹性</h3><p><strong>包裹性</strong>也是 float 的一个非常重要的特性，大家用 float 时一定要熟知这一特性。咱们还是先从一个小例子看起：</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/28/161db8f617bc8f2e?w=1310&h=180&f=png&s=15396" alt></p><p>如上图，普通的 div 如果没有设置宽度，它会撑满整个屏幕，在之前的盒子模型那一节也讲到过。而如果给 div 增加<code>float:left</code>之后，它突然变得紧凑了，宽度发生了变化，把内容中的三个字包裹了——这就是包裹性。为 div 设置了 float 之后，其宽度会自动调整为包裹住内容宽度，而不是撑满整个父容器。</p><p>注意，此时 div 虽然体现了包裹性，但是它的 display 样式是没有变化的，还是<code>display: block</code>。</p><p>float 为什么要具有包裹性？其实答案还是得从 float 的设计初衷来寻找，float 是被设计用于实现文字环绕效果的。文字环绕图片比较好理解，但是如果想要让文字环绕一个 div 呢？此时 div 不被“包裹”起来的话，就无法实现环绕效果了。</p><h3 id="清空格"><a href="#清空格" class="headerlink" title="清空格"></a>清空格</h3><p>float 还有一个大家可能不是很熟悉的特性——清空格。按照惯例，咱还是先举例子说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;border: 2px solid blue; padding:3px;&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;image/1.png&quot;/&gt;</span><br><span class="line">    &lt;img src=&quot;image/2.png&quot;/&gt;</span><br><span class="line">    &lt;img src=&quot;image/3.png&quot;/&gt;</span><br><span class="line">    &lt;img src=&quot;image/4.png&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/2/28/161db8f617bf4874?w=1376&h=148&f=png&s=71295" alt></p><p>加上<code>float:left</code>之后：</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/28/161db8f644302e40?w=1376&h=132&f=png&s=70562" alt></p><p>上面第一张图中，正常的 img 中间是会有空格的，因为多个 img 标签会有换行，而浏览器识别换行为空格，这也是很正常的。第二张图中，为 img 增加了<code>float:left</code>的样式，这就使得 img 之间没有了空格，4 个 img 紧紧挨着。</p><p>如果大家之前没注意，现在想想之前写过的程序，是不是有这个特性。为什么 float 适合用于网页排版（俗称“砌砖头”）？就是因为 float 排版出来的网页严丝合缝，中间连个苍蝇都飞不进去。</p><p>“清空格”这一特性的根本原因是 float 会导致节点脱离文档流结构。它都不属于文档流结构了，那么它身边的什么换行、空格就都和它没了关系，它就尽量往一边靠拢，能靠多近就靠多近，这就是清空格的本质。</p><blockquote><p>题目：手写 clearfix</p></blockquote><h3 id="clearfix"><a href="#clearfix" class="headerlink" title="clearfix"></a><code>clearfix</code></h3><p>清除浮动的影响，一般使用的样式如下，统称<code>clearfix</code>代码。所有 float 元素的父容器，一般情况下都应该加<code>clearfix</code>这个 class。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after &#123;</span><br><span class="line">    content: &apos;&apos;;</span><br><span class="line">    display: table;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix &#123;</span><br><span class="line">    *zoom: 1; /* 兼容 IE 低版本 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;clearfix&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;image/1.png&quot; style=&quot;float: left&quot;/&gt;</span><br><span class="line">    &lt;img src=&quot;image/2.png&quot; style=&quot;float: left&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>float 的设计初衷是解决文字环绕图片的问题，后来误打误撞用于做布局，因此有许多不合适或者需要注意的地方，上文基本都讲到了需要的知识点。如果是刚开始接触 float 的同学，学完上面的基础知识之后，还应该做一些练习实战一下 —— 经典的“圣杯布局”和“双飞翼布局”。这里就不再展开讲了，网上资料非常多，例如<a href="https://juejin.im/entry/5a8868cdf265da4e7e10c133?utm_source=gold_browser_extension" target="_blank" rel="noopener">浅谈面试中常考的两种经典布局——圣杯与双飞翼</a>（此文的最后两张图清晰地展示了这两种布局）。</p><hr><h2 id="定位position"><a href="#定位position" class="headerlink" title="定位position"></a>定位<code>position</code></h2><p>position 用于网页元素的定位，可设置 static/relative/absolute/fixed 这些值，其中 static 是默认值，不用介绍。</p><blockquote><p>题目：relative 和 absolute 有何区别？</p></blockquote><h3 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h3><p>相对定位 relative 可以用一个例子很轻松地演示出来。例如我们写 4 个<code>&lt;p&gt;</code>，出来的样子大家不用看也能知道。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;第一段文字&lt;/p&gt;</span><br><span class="line">&lt;p&gt;第二段文字&lt;/p&gt;</span><br><span class="line">&lt;p&gt;第三段文字&lt;/p&gt;</span><br><span class="line">&lt;p&gt;第四段文字&lt;/p&gt;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/2/28/161db8f645d10bf0?w=1280&h=382&f=png&s=33884" alt></p><p>然后我们在第三个<code>&lt;p&gt;</code>上面，加上<code>position:relative</code>并且设置<code>left</code>和<code>top</code>值，看这个<code>&lt;p&gt;</code>有什么变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;第一段文字&lt;/p&gt;</span><br><span class="line">&lt;p&gt;第二段文字&lt;/p&gt;</span><br><span class="line">&lt;p style=&quot;position:relative; top: 10px; left: 10px&quot;&gt;第三段文字&lt;/p&gt;</span><br><span class="line">&lt;p&gt;第四段文字&lt;/p&gt;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/2/28/161db8f644cb137d?w=1288&h=382&f=png&s=33953" alt></p><p>上图中，大家应该要识别出两个信息（相信大部分人会忽略第二个信息）</p><ul><li>第三个<code>&lt;p&gt;</code>发生了位置变化，分别向右向下移动了10px；</li><li>其他的三个<code>&lt;p&gt;</code>位置没有发生变化，这一点也很重要。</li></ul><p>可见，<strong>relative 会导致自身位置的相对变化，而不会影响其他元素的位置、大小</strong>。这是 relative 的要点之一。还有第二个要点，就是 relative 产生一个新的定位上下文。下文有关于定位上下文的详细介绍，这里可以先通过一个例子来展示一下区别：</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/23/161c1066884e2378?w=1031&h=337&f=png&s=37425" alt></p><p>注意看这两图的区别，下文将有解释。</p><h3 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h3><p>还是先写一个基本的 demo。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;第一段文字&lt;/p&gt;</span><br><span class="line">&lt;p&gt;第二段文字&lt;/p&gt;</span><br><span class="line">&lt;p style=&quot;background: yellow&quot;&gt;第三段文字&lt;/p&gt;</span><br><span class="line">&lt;p&gt;第四段文字&lt;/p&gt;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/2/28/161db8f64b045e56?w=1274&h=372&f=png&s=33793" alt></p><p>然后，我们把第三个<code>&lt;p&gt;</code>改为<code>position:absolute;</code>，看看会发生什么变化。</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/28/161db8f64768cf3e?w=1276&h=304&f=png&s=30596" alt></p><p>从上面的结果中，我们能看出几点信息：</p><ul><li>absolute 元素脱离了文档结构。和 relative 不同，其他三个元素的位置重新排列了。只要元素会脱离文档结构，它就会产生破坏性，导致父元素坍塌。（此时你应该能立刻想起来，float 元素也会脱离文档结构。）</li><li>absolute 元素具有“包裹性”。之前<code>&lt;p&gt;</code>的宽度是撑满整个屏幕的，而此时<code>&lt;p&gt;</code>的宽度刚好是内容的宽度。</li><li>absolute 元素具有“跟随性”。虽然 absolute 元素脱离了文档结构，但是它的位置并没有发生变化，还是老老实实地呆在它原本的位置，因为我们此时没有设置 top、left 的值。</li><li>absolute 元素会悬浮在页面上方，会遮挡住下方的页面内容。</li></ul><p>最后，通过给 absolute元素设置 top、left 值，可自定义其内容，这个都是平时比较常用的了。这里需要注意的是，设置了 top、left 值时，元素是相对于最近的定位上下文来定位的，而不是相对于浏览器定位。</p><h3 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h3><p>其实 fixed 和 absolute 是一样的，唯一的区别在于：absolute 元素是根据最近的定位上下文确定位置，而 fixed 根据 window （或者 iframe）确定位置。</p><blockquote><p>题目：relative、absolute 和 fixed 分别依据谁来定位？</p></blockquote><h3 id="定位上下文"><a href="#定位上下文" class="headerlink" title="定位上下文"></a>定位上下文</h3><p>relative 元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/23/161c1066a5b83ae8?w=448&h=105&f=png&s=2459" alt></p><p>fixed 元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/23/161c1066ab856721?w=516&h=135&f=png&s=2570" alt></p><p>absolute 的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了<code>position:relative/absolute/fixed</code>的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/23/161c1066ad4ffc63?w=576&h=183&f=png&s=5209" alt></p><p><img src="https://user-gold-cdn.xitu.io/2018/2/23/161c1066b419cfe6?w=516&h=137&f=png&s=2659" alt></p><hr><h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a><code>flex</code>布局</h2><p>布局的传统解决方案基于盒子模型，依赖 <code>display</code> 属性 + <code>position</code> 属性 + <code>float</code> 属性。它对于那些特殊布局非常不方便，比如，垂直居中（下文会专门讲解）就不容易实现。在目前主流的移动端页面中，使用 flex 布局能更好地完成需求，因此 flex 布局的知识是必须要掌握的。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>任何一个容器都可以使用 flex 布局，代码也很简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    .container &#123;</span><br><span class="line">      display: flex;</span><br><span class="line">    &#125;</span><br><span class="line">    .item &#123;</span><br><span class="line">        border: 1px solid #000;</span><br><span class="line">        flex: 1;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;aaa&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot; style=&quot;flex: 2&quot;&gt;bbb&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;ccc&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;ddd&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/2/23/161c1066b5766be2?w=796&h=122&f=png&s=11605" alt></p><p>注意，第三个<code>&lt;div&gt;</code>的<code>flex: 2</code>，其他的<code>&lt;div&gt;</code>的<code>flex: 1</code>，这样第二个<code>&lt;div&gt;</code>的宽度就是其他的<code>&lt;div&gt;</code>的两倍。</p><h3 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h3><p>设置了<code>display: flex</code>的元素，我们称为“容器”（flex container），其所有的子节点我们称为“成员”（flex item）。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/23/161c1066ba95ed28?w=1022&h=582&f=png&s=54081" alt></p><p>将以上文字和图片结合起来，再详细看一遍，这样就能理解 flex 的设计原理，才能更好地实际使用。</p><h3 id="设置主轴的方向"><a href="#设置主轴的方向" class="headerlink" title="设置主轴的方向"></a>设置主轴的方向</h3><p><code>flex-direction</code>可决定主轴的方向，有四个可选值：</p><ul><li>row（默认值）：主轴为水平方向，起点在左端。</li><li>row-reverse：主轴为水平方向，起点在右端。</li><li>column：主轴为垂直方向，起点在上沿。</li><li>column-reverse：主轴为垂直方向，起点在下沿。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  flex-direction: column-reverse| column | row | row-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码设置的主轴方向，将依次对应下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/23/161c1066cc8d122c?w=1898&h=418&f=png&s=39850" alt></p><h3 id="设置主轴的对齐方式"><a href="#设置主轴的对齐方式" class="headerlink" title="设置主轴的对齐方式"></a>设置主轴的对齐方式</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式，值如下：</p><ul><li>flex-start（默认值）：向主轴开始方向对齐。</li><li>flex-end：向主轴结束方向对齐。</li><li>center： 居中。</li><li>space-between：两端对齐，项目之间的间隔都相等。</li><li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/2/23/161c1066ccd09d05?w=1140&h=1020&f=png&s=68933" alt></p><h3 id="交叉轴的对齐方式"><a href="#交叉轴的对齐方式" class="headerlink" title="交叉轴的对齐方式"></a>交叉轴的对齐方式</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐，值如下：</p><ul><li>flex-start：交叉轴的起点对齐。</li><li>flex-end：交叉轴的终点对齐。</li><li>center：交叉轴的中点对齐。</li><li>baseline: 项目的第一行文字的基线对齐。</li><li>stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/2/23/161c1066d1feaa64?w=1064&h=1148&f=png&s=77952" alt></p><hr><h2 id="如何实现居中对齐？"><a href="#如何实现居中对齐？" class="headerlink" title="如何实现居中对齐？"></a>如何实现居中对齐？</h2><blockquote><p>题目：如何实现水平居中？</p></blockquote><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><p>inline 元素用<code>text-align: center;</code>即可，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">   text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>block 元素可使用<code>margin: auto;</code>，PC 时代的很多网站都这么搞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    text-align: center; </span><br><span class="line">&#125;</span><br><span class="line">.item &#123;</span><br><span class="line">    width: 1000px;</span><br><span class="line">    margin: auto; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绝对定位元素可结合<code>left</code>和<code>margin</code>实现，但是必须知道宽度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 500px;</span><br><span class="line">&#125;</span><br><span class="line">.item &#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    margin: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目：如何实现垂直居中？</p></blockquote><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><p>inline 元素可设置<code>line-height</code>的值等于<code>height</code>值，如单行文字垂直居中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">   height: 50px;</span><br><span class="line">   line-height: 50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绝对定位元素，可结合<code>left</code>和<code>margin</code>实现，但是必须知道尺寸。</p><ul><li>优点：兼容性好</li><li>缺点：需要提前知道尺寸</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.item &#123;</span><br><span class="line">    width: 80px;</span><br><span class="line">    height: 40px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    margin-top: -20px;</span><br><span class="line">    margin-left: -40px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绝对定位可结合<code>transform</code>实现居中。</p><ul><li>优点：不需要提前知道尺寸</li><li>缺点：兼容性不好</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.item &#123;</span><br><span class="line">    width: 80px;</span><br><span class="line">    height: 40px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line">    background: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绝对定位结合<code>margin: auto</code>，不需要提前知道尺寸，兼容性好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    height: 300px;</span><br><span class="line">&#125;</span><br><span class="line">.item &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 0;</span><br><span class="line">    top: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的解决方案还有，不过没必要掌握太多，能说出上文的这几个解决方案即可。</p><hr><h2 id="理解语义化"><a href="#理解语义化" class="headerlink" title="理解语义化"></a>理解语义化</h2><blockquote><p>题目：如何理解 HTML 语义化？</p></blockquote><p>所谓“语义”就是为了更易读懂，这要分两部分：</p><ul><li>让人（写程序、读程序）更易读懂</li><li>让机器（浏览器、搜索引擎）更易读懂</li></ul><h3 id="让人更易读懂"><a href="#让人更易读懂" class="headerlink" title="让人更易读懂"></a>让人更易读懂</h3><p>对于人来说，代码可读性、语义化就是一个非常广泛的概念了，例如定义 JS 变量的时候使用更易读懂的名称，定义 CSS class 的时候也一样，例如<code>length</code> <code>list</code>等，而不是使用<code>a</code> <code>b</code>这种谁都看不懂的名称。</p><p>不过我们平常考查的“语义化”并不会考查这么广义、这么泛的问题，而是考查 HTML 的语义化，是为了更好地让机器读懂 HTML。</p><h3 id="让机器更易读懂"><a href="#让机器更易读懂" class="headerlink" title="让机器更易读懂"></a>让机器更易读懂</h3><p>HTML 符合 XML 标准，但又和 XML 不一样 —— HTML 不允许像 XML 那样自定义标签名称，HTML 有自己规定的标签名称。问题就在这里 —— HTML 为何要自己规定那么多标签名称呢，例如<code>p</code> <code>div</code> <code>h1</code> <code>ul</code>等 —— 就是为了语义化。其实，如果你精通 CSS 的话，你完全可以全部用<code>&lt;div&gt;</code>标签来实现所有的网页效果，其他的<code>p</code> <code>h1</code> <code>ul</code>等标签可以一个都不用。但是我们不推荐这么做，这样做就失去了 HTML 语义化的意义。</p><p>拿搜索引擎来说，爬虫下载到我们网页的 HTML 代码，它如何更好地去理解网页的内容呢？—— 就是根据 HTML 既定的标签。<code>h1</code>标签就代表是标题；<code>p</code>里面的就是段落详细内容，权重肯定没有标题高；<code>ul</code>里面就是列表；<code>strong</code>就是加粗的强调的内容 …… 如果我们不按照 HTML 语义化来写，全部都用<code>&lt;div&gt;</code>标签，那搜索引擎将很难理解我们网页的内容。</p><p>为了加强 HTML 语义化，HTML5 标准中又增加了<code>header</code> <code>section</code> <code>article</code>等标签。因此，书写 HTML 时，语义化是非常重要的，否则 W3C 也没必要辛辛苦苦制定出这些标准来。</p><hr><h2 id="CSS3-动画"><a href="#CSS3-动画" class="headerlink" title="CSS3 动画"></a>CSS3 动画</h2><p>CSS3 可以实现动画，代替原来的 Flash 和 JavaScript 方案。</p><p>首先，使用<code>@keyframes</code>定义一个动画，名称为<code>testAnimation</code>，如下代码，通过百分比来设置不同的 CSS 样式，规定动画的变化。所有的动画变化都可以这么定义出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@keyframes testAnimation</span><br><span class="line">&#123;</span><br><span class="line">    0%   &#123;background: red; left:0; top:0;&#125;</span><br><span class="line">    25%  &#123;background: yellow; left:200px; top:0;&#125;</span><br><span class="line">    50%  &#123;background: blue; left:200px; top:200px;&#125;</span><br><span class="line">    75%  &#123;background: green; left:0; top:200px;&#125;</span><br><span class="line">    100% &#123;background: red; left:0; top:0;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，针对一个 CSS 选择器来设置动画，例如针对<code>div</code>元素设置动画，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    position: absolute;</span><br><span class="line"></span><br><span class="line">    animation-name: myfirst;</span><br><span class="line">    animation-duration: 5s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>animation-name</code>对应到动画名称，<code>animation-duration</code>是动画时长，还有其他属性：</p><ul><li><code>animation-timing-function</code>：规定动画的速度曲线。默认是<code>ease</code></li><li><code>animation-delay</code>：规定动画何时开始。默认是 0</li><li><code>animation-iteration-count</code>：规定动画被播放的次数。默认是 1</li><li><code>animation-direction</code>：规定动画是否在下一周期逆向地播放。默认是<code>normal</code></li><li><code>animation-play-state</code> ：规定动画是否正在运行或暂停。默认是<code>running</code></li><li><code>animation-fill-mode</code>：规定动画执行之前和之后如何给动画的目标应用，默认是<code>none</code>，保留在最后一帧可以用<code>forwards</code></li></ul><blockquote><p>题目：CSS 的<code>transition</code>和<code>animation</code>有何区别？</p></blockquote><p>首先<code>transition</code>和<code>animation</code>都可以做动效，从语义上来理解，<code>transition</code>是过渡，由一个状态过渡到另一个状态，比如高度<code>100px</code>过渡到<code>200px</code>；而<code>animation</code>是动画，即更专业做动效的，<code>animation</code>有帧的概念，可以设置关键帧<code>keyframe</code>，一个动画可以由多个关键帧多个状态过渡组成，另外<code>animation</code>也包含上面提到的多个属性。</p><h2 id="重绘和回流"><a href="#重绘和回流" class="headerlink" title="重绘和回流"></a>重绘和回流</h2><p>重绘和回流是面试题经常考的题目，也是性能优化当中应该注意的点，下面笔者简单介绍下。</p><ul><li><strong>重绘</strong>：指的是当页面中的元素不脱离文档流，而简单地进行样式的变化，比如修改颜色、背景等，浏览器重新绘制样式</li><li><strong>回流</strong>：指的是处于文档流中 DOM 的尺寸大小、位置或者某些属性发生变化时，导致浏览器重新渲染部分或全部文档的情况</li></ul><p>相比之下，<strong>回流要比重绘消耗性能开支更大</strong>。另外，一些属性的读取也会引起回流，比如读取某个 DOM 的高度和宽度，或者使用<code>getComputedStyle</code>方法。在写代码的时候要避免回流和重绘。比如在笔试中可能会遇见下面的题目：</p><blockquote><p>题目：找出下面代码的优化点，并且优化它</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var data = [&apos;string1&apos;, &apos;string2&apos;, &apos;string3&apos;];</span><br><span class="line">for(var i = 0; i &lt; data.length; i++)&#123;</span><br><span class="line">    var dom = document.getElementById(&apos;list&apos;);</span><br><span class="line">    dom.innerHTML += &apos;&lt;li&gt;&apos; + data[i] + &apos;&lt;/li&gt;&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码在循环中每次都获取<code>dom</code>，然后对其内部的 HTML 进行累加<code>li</code>，每次都会操作 DOM 结构，可以改成使用<code>documentFragment</code>或者先遍历组成 HTML 的字符串，最后操作一次<code>innerHTML</code>。</p><hr><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>本小节总结了 CSS 和 HTML 常考的知识点，包括 CSS 中比较重要的定位、布局的知识，也介绍了一些 CSS3 的知识点概念和题目，以及 HTML 的语义化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CSS 和 HTML 是网页开发中布局相关的组成部分，涉及的内容比较多和杂乱，本小节重点介绍下常考的知识点。&lt;/p&gt;
&lt;h2 id=&quot;知识点梳理&quot;&gt;&lt;a href=&quot;#知识点梳理&quot; class=&quot;headerlink&quot; title=&quot;知识点梳理&quot;&gt;&lt;/a&gt;知识点梳理&lt;/h2
      
    
    </summary>
    
    
      <category term="知识点梳理" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>原型和原型链</title>
    <link href="http://yoursite.com/2019/08/22/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2019/08/22/原型和原型链/</id>
    <published>2019-08-22T13:46:39.000Z</published>
    <updated>2019-08-22T13:49:31.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><p>JavaScript 是基于原型的语言，原型理解起来非常简单，但却特别重要，下面还是通过题目来理解下JavaScript 的原型概念。</p><blockquote><p>题目：如何理解 JavaScript 的原型</p></blockquote><p>对于这个问题，可以从下面这几个要点来理解和回答，<strong>下面几条必须记住并且理解</strong></p><ul><li><strong>所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（<code>null</code>除外）</strong></li><li><strong>所有的引用类型（数组、对象、函数），都有一个<code>__proto__</code>属性，属性值是一个普通的对象</strong></li><li><strong>所有的函数，都有一个<code>prototype</code>属性，属性值也是一个普通的对象</strong></li><li><strong>所有的引用类型（数组、对象、函数），<code>__proto__</code>属性值指向它的构造函数的<code>prototype</code>属性值</strong></li></ul><p>通过代码解释一下，大家可自行运行以下代码，看结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 要点一：自由扩展属性</span><br><span class="line">var obj = &#123;&#125;; obj.a = 100;</span><br><span class="line">var arr = []; arr.a = 100;</span><br><span class="line">function fn () &#123;&#125;</span><br><span class="line">fn.a = 100;</span><br><span class="line"></span><br><span class="line">// 要点二：__proto__</span><br><span class="line">console.log(obj.__proto__);</span><br><span class="line">console.log(arr.__proto__);</span><br><span class="line">console.log(fn.__proto__);</span><br><span class="line"></span><br><span class="line">// 要点三：函数有 prototype</span><br><span class="line">console.log(fn.prototype)</span><br><span class="line"></span><br><span class="line">// 要点四：引用类型的 __proto__ 属性值指向它的构造函数的 prototype 属性值</span><br><span class="line">console.log(obj.__proto__ === Object.prototype)</span><br></pre></td></tr></table></figure><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>先写一个简单的代码示例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 构造函数</span><br><span class="line">function Foo(name, age) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.alertName = function () &#123;</span><br><span class="line">    alert(this.name)</span><br><span class="line">&#125;</span><br><span class="line">// 创建示例</span><br><span class="line">var f = new Foo(&apos;zhangsan&apos;)</span><br><span class="line">f.printName = function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line">// 测试</span><br><span class="line">f.printName()</span><br><span class="line">f.alertName()</span><br></pre></td></tr></table></figure><p>执行<code>printName</code>时很好理解，但是执行<code>alertName</code>时发生了什么？这里再记住一个重点 <strong>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的<code>__proto__</code>（即它的构造函数的<code>prototype</code>）中寻找</strong>，因此<code>f.alertName</code>就会找到<code>Foo.prototype.alertName</code>。</p><p>那么如何判断这个属性是不是对象本身的属性呢？使用<code>hasOwnProperty</code>，常用的地方是遍历一个对象的时候。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var item</span><br><span class="line">for (item in f) &#123;</span><br><span class="line">    // 高级浏览器已经在 for in 中屏蔽了来自原型的属性，但是这里建议大家还是加上这个判断，保证程序的健壮性</span><br><span class="line">    if (f.hasOwnProperty(item)) &#123;</span><br><span class="line">        console.log(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>还是接着上面的示例，如果执行<code>f.toString()</code>时，又发生了什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 省略 N 行</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">f.printName()</span><br><span class="line">f.alertName()</span><br><span class="line">f.toString()</span><br></pre></td></tr></table></figure><p>因为<code>f</code>本身没有<code>toString()</code>，并且<code>f.__proto__</code>（即<code>Foo.prototype</code>）中也没有<code>toString</code>。这个问题还是得拿出刚才那句话——<strong>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的<code>__proto__</code>（即它的构造函数的<code>prototype</code>）中寻找</strong>。</p><p>如果在<code>f.__proto__</code>中没有找到<code>toString</code>，那么就继续去<code>f.__proto__.__proto__</code>中寻找，因为<code>f.__proto__</code>就是一个普通的对象而已嘛！</p><ul><li><code>f.__proto__</code>即<code>Foo.prototype</code>，没有找到<code>toString</code>，继续往上找</li><li><code>f.__proto__.__proto__</code>即<code>Foo.prototype.__proto__</code>。<code>Foo.prototype</code>就是一个普通的对象，因此<code>Foo.prototype.__proto__</code>就是<code>Object.prototype</code>，在这里可以找到<code>toString</code></li><li>因此<code>f.toString</code>最终对应到了<code>Object.prototype.toString</code></li></ul><p>这样一直往上找，你会发现是一个链式的结构，所以叫做“原型链”。如果一直找到最上层都没有找到，那么就宣告失败，返回<code>undefined</code>。最上层是什么 —— <code>Object.prototype.__proto__ === null</code></p><h3 id="原型链中的this"><a href="#原型链中的this" class="headerlink" title="原型链中的this"></a>原型链中的<code>this</code></h3><p>所有从原型或更高级原型中得到、执行的方法，其中的<code>this</code>在执行时，就指向了当前这个触发事件执行的对象。因此<code>printName</code>和<code>alertName</code>中的<code>this</code>都是<code>f</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原型和原型链&quot;&gt;&lt;a href=&quot;#原型和原型链&quot; class=&quot;headerlink&quot; title=&quot;原型和原型链&quot;&gt;&lt;/a&gt;原型和原型链&lt;/h2&gt;&lt;p&gt;JavaScript 是基于原型的语言，原型理解起来非常简单，但却特别重要，下面还是通过题目来理解下Java
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>模块化进化史</title>
    <link href="http://yoursite.com/2019/08/22/%E6%A8%A1%E5%9D%97%E5%8C%96%E8%BF%9B%E5%8C%96%E5%8F%B2/"/>
    <id>http://yoursite.com/2019/08/22/模块化进化史/</id>
    <published>2019-08-22T13:37:15.000Z</published>
    <updated>2019-08-22T13:51:19.069Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模块化的理解"><a href="#模块化的理解" class="headerlink" title="模块化的理解"></a>模块化的理解</h3><p>将一个复杂的程序按一定规则拆分成几个块，块与块内部实现是私有的，相互独立，只是向外暴露指定方法与外部其他块通信</p><h5 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h5><ul><li>避免命名冲突</li><li>更好的分离，按需加载</li><li>更高的复用性</li><li>更高的可维护性<a id="more"></a></li></ul><h3 id="模块的进化"><a href="#模块的进化" class="headerlink" title="模块的进化"></a>模块的进化</h3><h4 id="1-全局function模式：将不同功能封装成全局函数"><a href="#1-全局function模式：将不同功能封装成全局函数" class="headerlink" title="1.全局function模式：将不同功能封装成全局函数"></a>1.全局function模式：将不同功能封装成全局函数</h4><p>问题：污染全局命名空间，容易引起命名冲突，而且模块之间看不出直接关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function m1()&#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line">function m2()&#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-namespace模式-简单对象封装"><a href="#2-namespace模式-简单对象封装" class="headerlink" title="2.namespace模式 : 简单对象封装"></a>2.namespace模式 : 简单对象封装</h4><p>作用：减少了全局变量<br>问题：数据不安全（外部可以直接修改模块内变量）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let myModule = &#123;</span><br><span class="line">  data: &apos;www.baidu.com&apos;,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    console.log(`foo(this.data)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">myModule.data = &apos;other data&apos; //能直接修改模块内部的数据</span><br><span class="line">myModule.foo() // foo() other data</span><br></pre></td></tr></table></figure><h4 id="3-IIFE模式：匿名函数自调用-闭包"><a href="#3-IIFE模式：匿名函数自调用-闭包" class="headerlink" title="3.IIFE模式：匿名函数自调用(闭包)"></a>3.IIFE模式：匿名函数自调用(闭包)</h4><p>作用：模块是私有的，外部只能通过暴露的接口访问<br>编码：通过添加window的属性暴露接口<br>问题：如果依赖其他模块，在引用模块的时候顺序要求严格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// module.js文件</span><br><span class="line">(function(window, $) &#123;</span><br><span class="line">  let data = &apos;www.baidu.com&apos;</span><br><span class="line">  //操作数据的函数</span><br><span class="line">  function foo() &#123;</span><br><span class="line">    //用于暴露有函数</span><br><span class="line">    console.log(`foo() $&#123;data&#125;`)</span><br><span class="line">    $(&apos;body&apos;).css(&apos;background&apos;, &apos;red&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  function bar() &#123;</span><br><span class="line">    //用于暴露有函数</span><br><span class="line">    console.log(`bar() $&#123;data&#125;`)</span><br><span class="line">    otherFun() //内部调用</span><br><span class="line">  &#125;</span><br><span class="line">  function otherFun() &#123;</span><br><span class="line">    //内部私有的函数</span><br><span class="line">    console.log(&apos;otherFun()&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  //暴露行为</span><br><span class="line">  window.myModule = &#123; foo, bar &#125;</span><br><span class="line">&#125;)(window, jQuery)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line">  &lt;!-- 引入的js必须有一定顺序 --&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.10.1.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    myModule.foo()</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="4-模块化规范"><a href="#4-模块化规范" class="headerlink" title="4.模块化规范"></a>4.模块化规范</h4><ul><li>CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本语法</span><br><span class="line">暴露模块：module.exports = value或exports.xxx = value</span><br><span class="line">引入模块：require(xxx),如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径</span><br></pre></td></tr></table></figure><ul><li>AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">定义暴露模块:</span><br><span class="line"></span><br><span class="line">//定义没有依赖的模块</span><br><span class="line">define(function()&#123;</span><br><span class="line">   return 模块</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//定义有依赖的模块</span><br><span class="line">define([&apos;module1&apos;, &apos;module2&apos;], function(m1, m2)&#123;</span><br><span class="line">   return 模块</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">引入使用模块:</span><br><span class="line">require([&apos;module1&apos;, &apos;module2&apos;], function(m1, m2)&#123;</span><br><span class="line">   使用m1/m2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">定义暴露模块：</span><br><span class="line"></span><br><span class="line">//定义没有依赖的模块</span><br><span class="line">define(function(require, exports, module)&#123;</span><br><span class="line">  exports.xxx = value</span><br><span class="line">  module.exports = value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//定义有依赖的模块</span><br><span class="line">define(function(require, exports, module)&#123;</span><br><span class="line">  //引入依赖模块(同步)</span><br><span class="line">  var module2 = require(&apos;./module2&apos;)</span><br><span class="line">  //引入依赖模块(异步)</span><br><span class="line">    require.async(&apos;./module3&apos;, function (m3) &#123;</span><br><span class="line">    &#125;)</span><br><span class="line">  //暴露模块</span><br><span class="line">  exports.xxx = value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">引入使用模块：</span><br><span class="line"></span><br><span class="line">define(function (require) &#123;</span><br><span class="line">  var m1 = require(&apos;./module1&apos;)</span><br><span class="line">  var m4 = require(&apos;./module4&apos;)</span><br><span class="line">  m1.show()</span><br><span class="line">  m4.show()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</span><br><span class="line"></span><br><span class="line">/** 定义模块 math.js **/</span><br><span class="line">var basicNum = 0;</span><br><span class="line">var add = function (a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;;</span><br><span class="line">export &#123; basicNum, add &#125;;</span><br><span class="line">/** 引用模块 **/</span><br><span class="line">import &#123; basicNum, add &#125; from &apos;./math&apos;;</span><br><span class="line">function test(ele) &#123;</span><br><span class="line">    ele.textContent = add(99 + basicNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default命令，为模块指定默认输出。</span><br><span class="line">// export-default.js</span><br><span class="line">export default function () &#123;</span><br><span class="line">  console.log(&apos;foo&apos;);</span><br><span class="line"></span><br><span class="line">// import-default.js</span><br><span class="line">import customName from &apos;./export-default&apos;;</span><br><span class="line">customName(); // &apos;foo&apos;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;模块化的理解&quot;&gt;&lt;a href=&quot;#模块化的理解&quot; class=&quot;headerlink&quot; title=&quot;模块化的理解&quot;&gt;&lt;/a&gt;模块化的理解&lt;/h3&gt;&lt;p&gt;将一个复杂的程序按一定规则拆分成几个块，块与块内部实现是私有的，相互独立，只是向外暴露指定方法与外部其他块通信&lt;/p&gt;
&lt;h5 id=&quot;模块化的好处&quot;&gt;&lt;a href=&quot;#模块化的好处&quot; class=&quot;headerlink&quot; title=&quot;模块化的好处&quot;&gt;&lt;/a&gt;模块化的好处&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;避免命名冲突&lt;/li&gt;
&lt;li&gt;更好的分离，按需加载&lt;/li&gt;
&lt;li&gt;更高的复用性&lt;/li&gt;
&lt;li&gt;更高的可维护性
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>http协议基础（下)</title>
    <link href="http://yoursite.com/2018/08/21/http%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%E4%B8%8B/"/>
    <id>http://yoursite.com/2018/08/21/http协议基础下/</id>
    <published>2018-08-21T14:20:47.000Z</published>
    <updated>2019-08-22T13:40:38.771Z</updated>
    
    <content type="html"><![CDATA[<p><strong>http状态码</strong></p><blockquote><ul><li>1XX:接收信息正在处理</li><li>2XX:正常处理完毕（200请求成功）</li></ul></blockquote><a id="more"></a><blockquote><ul><li>3XX:重定向<ul><li>301 永久重定向</li><li>302 临时重定向</li></ul></li><li>4XX:客户端错误<ul><li>400:语法错误（参数不对）</li><li>401:未认证</li><li>403:禁止访问</li><li>404:资源未找到</li></ul></li><li>5XX:服务器错误<ul><li>500:服务器出错</li><li>503:服务器繁忙</li></ul></li></ul></blockquote><p><strong>HTTP首部字段</strong></p><blockquote><p><em>通用首部字段</em></p><ul><li>Cach-Control 控制缓存的行为</li><li>Date 创建报文的事件</li><li>Connection 连接管理</li><li>Pragma：报文指令</li><li>Trailer：报文末端的首部一览</li><li>Transfer-Encoding：指定报文主体的传输编码方式</li><li>Upgrade：升级为其他协议</li><li>Via：代理服务器的相关信息</li><li>Warning：错误通知</li></ul></blockquote><blockquote><p><em>请求首部字段（Request Header Fields）</em></p><ul><li>从客户端向服务器发送求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</li><li>Accept：用户代理可处理的媒体类型</li><li>Accept-Charset：优先的字符集</li><li>Accept-Encoding：优先的内容编码</li><li>Accept-Language：优先的语言（自然语言）</li><li>Authorization：Web认证信息</li><li>Expect：期待服务器的特定行为</li><li>From：用户的电子邮箱地址</li><li>Host：请求资源所在服务器</li><li>If-Match：比较实体标记（ETag）</li><li>If-Modified-Since：比较资源的更新时间</li><li>If-None-Match：比较实体标记（与If-Match相反）</li><li>If-Range：资源未更新时发送实体Byte的范围请求</li><li>If-Unmodified-Since：比较资源的更新时间（与If-Modified-Since相反）</li><li>Max-Forwards：最大传输逐跳数</li><li>Proxy-Authorization：代理服务器要求客户端的认真信息</li><li>Range：实体的直接范围请求</li><li>Referer：对请求中URI的原始获取方</li><li>TE：传输编码的优先级</li><li>User-Agent：HTTP客户端程序的信息</li></ul></blockquote><blockquote><p><em>响应首部字段（Response Header Fields）</em></p><ul><li>从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会请求客户端附加额外的内容信息。</li><li>Accept-Ranges：是否接受字节范围请求</li><li>Age：推算资源创建经过时间</li><li>ETag：资源的匹配信息</li><li>Location：令客户端重定向至指定URI</li><li>Proxy-Authenticate：代理服务器对客户端的认真信息</li><li>Retry-After：对再次发起请求的时机请求</li><li>Server：HTTP服务器的安装信息</li><li>Vary：代理服务器缓存的管理信息</li><li>WWW-Authenticate：服务器对客户端的认真信息</li></ul></blockquote><blockquote><p><em>实体首部字段（Entity Header Fields）</em><br>针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体相关的信息。</p></blockquote><ul><li>Allow：资源可支持的HTTP方法</li><li>Content-Encoding：实体主体适用的编码方法</li><li>Content-Language：实体主体的自然语言</li><li>Content-Length：实体主体的大小（单位：字节）</li><li>Content-Location：替代对应资源的URI</li><li>Content-MD5：实体主体的报文摘要</li><li>Content-Range：实体主体的位置范围</li><li>Content-Type：实体主体的媒体类型</li><li>Expires：实体主体过期的日期时间</li><li>Last-Modified：资源的最后修改日期时间</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;http状态码&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1XX:接收信息正在处理&lt;/li&gt;
&lt;li&gt;2XX:正常处理完毕（200请求成功）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存机制</title>
    <link href="http://yoursite.com/2018/08/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/08/21/浏览器缓存机制/</id>
    <published>2018-08-21T12:29:58.000Z</published>
    <updated>2019-08-22T13:02:15.863Z</updated>
    
    <content type="html"><![CDATA[<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>浏览器缓存机制是“通过 HTTP 协议 header 里的Cache-Control（或Expires）和Last-Modified（或Etag）等字段来控制文件缓存的机制”</p><a id="more"></a><h4 id="使用缓存的优点"><a href="#使用缓存的优点" class="headerlink" title="使用缓存的优点"></a>使用缓存的优点</h4><ul><li>减小网络带宽消耗</li><li>降低服务器压力</li><li>减小网络延迟，加快页面打开速度</li></ul><h4 id="浏览器缓存规则"><a href="#浏览器缓存规则" class="headerlink" title="浏览器缓存规则"></a>浏览器缓存规则</h4><p>新鲜度（过期机制）：缓存副本有效期</p><p>校验值（校验机制）：缓存实体标签etag</p><h4 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h4><p><strong>首次请求</strong></p><blockquote><p>这时候浏览器端是 没有缓存 的，所以会直接向服务器发送请求，且 不携带任何缓存相关参数，服务器接收到资源请求时，会在响应头中加入如下 参数(注意：这些参数对于浏览器而言是有优先级的！且对应着“浏览器端不同的缓存策略”)</p><ul><li>Expires：服务端设置的一个“资源过期时间”，但是因为客户端和服务端时间有误差，会导致缓存命中的误差，因此优先级较低</li><li>Cache-Control：控制缓存的行为，一般取值有 private（默认）、public、no-cache、max-age，no-store，但我们一般常见的值是 max-age，缓存的内容将在多少秒后失效</li><li>Last-Modified：资源的最后修改时间。</li><li>ETag：资源在服务器的唯一标识（生成规则由服务器决定，例如内容的hash值）</li></ul></blockquote><blockquote><p>对于浏览器接收到这些头参数的优先级是：Cache-Control &gt; Expires &gt; ETag &gt; Last-Modified,至此,服务端就将携带缓存头参数的信息返回给了浏览器，浏览器接收之后,一方面解析加载到浏览器上，另一方面会存储下来</p></blockquote><p><strong>再次请求</strong></p><blockquote><ul><li>先判断本地是否有缓存，没有的话，就回到第一次请求的流程</li><li>判断缓存是否过期,如果没过期,不需要发出请求，直接使用缓存资源即可,<strong>所谓强缓存</strong></li><li>如果过期了就会检查 <code>ETag</code> 和 <code>Last-Modified</code> 这两个参数，无论如何都会再次向服务器发出请求，ETag 对应头参数 <code>If-None-Match</code>，<code>Last-Modified</code> 对应头参数 <code>If-Modified-Since</code>，前者优先级更高，向服务端发起携带缓存头参数<code>If-None-Match</code> 和<code>If-Modified-Since</code>的请求后，服务端会决策浏览器端缓存的资源是否是最新的。如果是,就会返回只带响应头的响应报文，且状态码是我们常见的<code>304</code>。<strong>即协商缓存</strong>否则就会和第一次请求一样，重新返回最新的资源。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h4&gt;&lt;p&gt;浏览器缓存机制是“通过 HTTP 协议 header 里的Cache-Control（或Expires）和Last-Modified（或Etag）等字段来控制文件缓存的机制”&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>options请求是什么鬼</title>
    <link href="http://yoursite.com/2018/08/20/options/"/>
    <id>http://yoursite.com/2018/08/20/options/</id>
    <published>2018-08-20T15:06:00.000Z</published>
    <updated>2019-08-22T13:02:41.849Z</updated>
    
    <content type="html"><![CDATA[<p>options出现的情况只有两种：</p><blockquote><ul><li>1、获取目的资源所支持的通信方式<br>黑客有可能经常用到这个；在响应报文中包含一个Allow首部字段，该字段的值表明了服务器支持的所有HTTP方法，如下：</li><li>2、跨域请求中，options请求是浏览器自发起的preflight request(预检请求)，以检测实际请求是否可以被浏览器接受.</li></ul></blockquote><a id="more"></a><p>在我们开发过程中出现的浏览器自发起的options请求就是上面的第二种情况。实际上，跨域请求中的”复杂请求”发出前会进行一次方法是options的preflight request。</p><p>符合以下任一情况的就是复杂请求：</p><blockquote><p>1.使用方法put或者delete;<br>2.发送json格式的数据（content-type: application/json）<br>3.请求中带有自定义头部；</p></blockquote><p>为什么跨域的复杂请求需要preflight request？</p><blockquote><p>复杂请求可能对服务器数据产生副作用。例如delete或者put,都会对服务器数据进行修改,所以在请求之前都要先询问服务器，当前网页所在域名是否在服务器的许可名单中，服务器允许后，浏览器才会发出正式的请求，否则不发送正式请求。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;options出现的情况只有两种：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1、获取目的资源所支持的通信方式&lt;br&gt;黑客有可能经常用到这个；在响应报文中包含一个Allow首部字段，该字段的值表明了服务器支持的所有HTTP方法，如下：&lt;/li&gt;
&lt;li&gt;2、跨域请求中，options请求是浏览器自发起的preflight request(预检请求)，以检测实际请求是否可以被浏览器接受.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>Referer</title>
    <link href="http://yoursite.com/2018/08/20/reffer/"/>
    <id>http://yoursite.com/2018/08/20/reffer/</id>
    <published>2018-08-20T14:55:51.000Z</published>
    <updated>2019-08-22T13:02:47.245Z</updated>
    
    <content type="html"><![CDATA[<p>Referer  是  HTTP  请求header 的一部分，当浏览器（或者模拟浏览器行为）向web 服务器发送请求的时候，头信息里有包含  Referer  。比如我在<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 里有一个<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 链接，那么点击这个<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> ，它的header 信息里就有：<code>Referer=http://www.google.com</code>它就是表示一个来源。</p><a id="more"></a><p><strong>Referer的作用？</strong></p><blockquote><ul><li>1.防盗链。<br>比如我只允许我自己的网站访问我自己的图片服务器，那我的域名是<a href="http://www.google.com，" target="_blank" rel="noopener">www.google.com，</a> 那么图片服务器每次取到Referer来判断一下是不是我自己的域名<a href="http://www.google.com，" target="_blank" rel="noopener">www.google.com，</a> 如果是就继续访问，不是就拦截。</li><li>防止恶意请求(CSRF).</li></ul></blockquote><p><strong>空Referer是怎么回事</strong></p><blockquote><p>直接在浏览器的地址栏中输入一个资源的URL地址，那么这种请求是不会包含 Referer  字段的，因为这是一个“凭空产生”的 HTTP  请求，并不是从一个地方链接过去的</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Referer  是  HTTP  请求header 的一部分，当浏览器（或者模拟浏览器行为）向web 服务器发送请求的时候，头信息里有包含  Referer  。比如我在&lt;a href=&quot;http://www.google.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.google.com&lt;/a&gt; 里有一个&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.baidu.com&lt;/a&gt; 链接，那么点击这个&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.baidu.com&lt;/a&gt; ，它的header 信息里就有：&lt;code&gt;Referer=http://www.google.com&lt;/code&gt;它就是表示一个来源。&lt;/p&gt;
    
    </summary>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>http协议基础（上）</title>
    <link href="http://yoursite.com/2018/08/20/http%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/08/20/http协议基础/</id>
    <published>2018-08-20T13:50:49.000Z</published>
    <updated>2019-08-22T13:02:09.828Z</updated>
    
    <content type="html"><![CDATA[<p><strong>什么是Http协议</strong></p><blockquote><p>超文本传输协议，是一个应用层协议，通过浏览器和服务器进行数据交互，进行超文本（文本、图片、视频等）传输的规定。</p></blockquote><a id="more"></a><p><strong>http协议结构组成</strong></p><blockquote><p>请求行（包括url，请求方式，状态码，http协议版本）<br>请求头<br>请求体</p></blockquote><p><strong>http协议中有哪些请求方式</strong></p><blockquote><p>GET:用于请求访问已经被URI(统一资源标识符)识别的资源,可以通过URL传参给服务器<br>POST:用于传输信息给服务器,主要功能与GET方法类似,但一般推荐使用POST方式<br>PUT:传输文件,报文主体中包含文件内容,保存到对应URI位置<br>HEAD:获得报文首部,与GET方法类似,只是不返回报文主体,一般用于验证URI是否有效<br>DELETE:删除文件,与PUT方法相反,删除对应URI位置的文件<br>OPTIONS:查询响应URI支持的HTTP方法</p></blockquote><p><strong>GET和POST的区别</strong></p><blockquote><ul><li>get重点在从服务器上获取资源,post重点在想服务器发送数据;</li><li>get传输数据是通过URL请求,以filed(字段)=value的形式,置于URL后,并用”?”连接,多个请求数据之间用<br>“&amp;”连接,这个过程用户是可见的,post是放在请求体内</li><li>get传输量小,因为受URL长度限制,但效率较低/post可以传输大量数据,所以上传文件时只能用post方式</li><li>get是不安全的,因为URL是可见的,可能会泄露私密信息,如密码等</li></ul></blockquote><p><strong>HTTP和https区别</strong></p><blockquote><ul><li>https协议需要到ca申请证书，一般免费证书很少，需要交费。</li><li>http是超文本传输协议，信息是明文传输，https 则是具有安全性的<code>ssl</code>加密传输协议。</li><li>http和https使用的是完全不同的连接方式用的端口也不一样，前者是80，后者是443。</li><li>http的连接很简单，是无状态的。HTTPS协议是由<code>SSL+HTTP</code>协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</li></ul></blockquote><p><strong>http1.0和http1.1区别</strong></p><blockquote><ul><li>建立连接方面: HTTP/1.0 每次请求都需要建立新的TCP连接，连接不能复用。HTTP/1.1 新的请求可以在上次请求建立的TCP连接之上发送，连接可以复用。优点是减少重复进行TCP三次握手的开销，提高效率。</li><li>HTTP1.1增加了<code>OPTIONS</code>, <code>PUT</code>, <code>DELETE,</code> <code>TRACE</code>, <code>CONNECT</code>这些Request方法</li></ul></blockquote><p> <strong>无状态</strong></p><blockquote><p>由于http是一种无状态的协议，因此无论是客户端还是服务器都不记录http的相关信息。这样设计一方面减轻了服务器端的负载，另一方面减小了http请求的开销。<br><code>cookie</code>和<code>session</code>用于解决http无状态的问题</p></blockquote><p><strong>持久化</strong></p><blockquote><p>正常在发送http时，都需要建立<code>TCP</code>的连接，再发送报文,　如果每次想要发送http报文都需要经过这个过程，那么时间大部分都会消耗在建立和断开连接的过程中。因此http中使用了<code>connection</code>属性，用于指定连接的方式。当设置成<code>keep-alive</code>，就会建立一条持久化的连接。不需要每次都建立连接，再中断。</p></blockquote><p><strong>管道化</strong></p><blockquote><p>http可以一次发送多个http请求，然后等待响应连接。不需要排队等候，这样就加快了http的响应时间。</p></blockquote><p><strong>内容编码</strong></p><blockquote><p>由于某些报文的内容过大，因此在传输时，为了减少传输的时间，会采取一些压缩的措施。例如<code>accept-Encoding</code>定义了内容编码的格式：<code>gzip</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;什么是Http协议&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;超文本传输协议，是一个应用层协议，通过浏览器和服务器进行数据交互，进行超文本（文本、图片、视频等）传输的规定。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="http协议" scheme="http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>前端安全防御</title>
    <link href="http://yoursite.com/2018/08/19/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%98%B2%E5%BE%A1/"/>
    <id>http://yoursite.com/2018/08/19/前端安全防御/</id>
    <published>2018-08-19T12:27:35.000Z</published>
    <updated>2019-08-22T13:02:20.511Z</updated>
    
    <content type="html"><![CDATA[<p><strong>CSRF（Cross Site Request Forgy）跨站请求伪造</strong></p><blockquote><p>原理：在第三方网站向本网站发请求<br>（1）用户在a站前端页面发起登录（身份认证）请求<br>（2）a站后端确认身份，登录成功，cookie中存在用户的身份认证信息<br>（3）b站前端页面向a站后端发起请求，带着a站的cookie信息（身份认证信息），请求成功</p></blockquote><a id="more"></a><blockquote><p>特点：<br>b站发送的请求带着a站的cookie信息；<br>b站发送请求不经过a站的前端；<br>http请求头中的referer为b站</p></blockquote><blockquote><p>防御：<br>（1）禁止第三方网站携带本网站的cookie信息：设置same-site属性，same-site属性有两个值，Strict（所有的第三方请求都不能携带本网站的cookie）和Lax（链接可以，但是form表单提交和ajax请求不行）<br>（2）本网站前端页面添加验证信息：使用验证码或者添加token验证<br>（3）referer验证：禁止来自第三方的请求</p></blockquote><p><strong>XSS（Cross Site Scripting）跨站脚本攻击</strong></p><blockquote><p>(1）原理：页面渲染的数据中包含可运行的脚本<br>(2）攻击的基本类型：反射型（url参数直接注入）和存储型（存储到DB后读取时注入）<br>(3）注入点：HTML节点内的内容（text）；HTML中DOM元素的属性；Javascript代码；富文本</p></blockquote><blockquote><p>如何防御<br>（1）浏览器自带防御机制，主要应对反射型攻击（HTML内容或属性）：http响应头中自动添加x-xss-protection，值为0（关闭），1（打开），默认打开<br>（2）对特定字符做转义：内容注入替换尖括号（ &lt; =&gt; &lt;   &gt; =&gt; &gt; ） 属性注入替换单引号或双引号（ “ =&gt; &quot;  ‘ =&gt; &#39; ）<br>（3）CSP（Content Security Policy）内容安全策略：用于指定哪些内容可执行</p></blockquote><p><strong>点击劫持</strong></p><blockquote><p>原理：<br>第三方网站通过iframe内嵌某一个网站，并且将iframe设置为透明不可见，将其覆盖在其他经过伪装的DOM上，伪装的可点击DOM（按钮等）与实际内嵌网站的可点击DOM位置相同，当用户点击伪装的DOM时，实际上点击的是iframe中内嵌的网页的DOM从而触发请求操作</p></blockquote><blockquote><p>特点：<br>用户自己做了点击操作；用户毫不知情；</p></blockquote><blockquote><p>防御<br>Javascript禁止内嵌：当网页没有被使用iframe内嵌时，top和window是相等的；当网页被内嵌时，top和window是不相等的；可以在本网站的页面中添加如下判断</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;CSRF（Cross Site Request Forgy）跨站请求伪造&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原理：在第三方网站向本网站发请求&lt;br&gt;（1）用户在a站前端页面发起登录（身份认证）请求&lt;br&gt;（2）a站后端确认身份，登录成功，cookie中存在用户的身份认证信息&lt;br&gt;（3）b站前端页面向a站后端发起请求，带着a站的cookie信息（身份认证信息），请求成功&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="前端安全防御" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%98%B2%E5%BE%A1/"/>
    
  </entry>
  
  <entry>
    <title>JS继承的继承方式</title>
    <link href="http://yoursite.com/2018/08/19/JS%E7%BB%A7%E6%89%BF%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/08/19/JS继承的继承方式/</id>
    <published>2018-08-18T18:08:57.000Z</published>
    <updated>2019-08-22T13:02:36.643Z</updated>
    
    <content type="html"><![CDATA[<p><strong>原型链继承</strong></p><p><code>利用prototype将子构造函数的prototype指向Person达到继承的目的</code>；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.country=&apos;china&apos;;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.play = function()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child(age)&#123;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = new Person();</span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li><code>创建子类实例时，但是无法给父构造函数传参</code></li><li><code>来自原型对象的引用属性是所有实例共享的</code></li></ul><a id="more"></a><p><strong>构造函数继承</strong></p><p><code>在子类构造函数中借用call调用父类构造函数</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.country=&apos;china&apos;;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.play = function()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child(name,age)&#123;</span><br><span class="line">    this.age = age;</span><br><span class="line">    Person.call(this,name)</span><br><span class="line">&#125;</span><br><span class="line">var obj = new Child(&apos;小明&apos;，16);</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li><code>解决了子类构造函数向父类构造函数传参数和实例共享原型属性的问题</code></li></ul><p>缺点：</p><ul><li><code>相当于每个实例都拷贝了一份父类的方法，占用内存大</code></li><li><code>不能继承原型属性/方法，只能继承父类的实例属性和方法</code></li></ul><p><strong>组合继承</strong></p><p><code>使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.country=&apos;china&apos;;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.play = function()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">function Child(name,age)&#123;</span><br><span class="line">    Person.call(this,name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = new Person();</span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li><code>会调用两次父类构造函数</code></li><li></li></ul><p><strong>原型式继承</strong></p><p><code>基于已有对象，创建新对象</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 在object函数内部，先创建了一个临时的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个新实例。</span><br><span class="line">// 从本质上讲，object()对传入其中的对象执行了一次浅复制。</span><br><span class="line"></span><br><span class="line">function object (o) &#123;</span><br><span class="line">  function F() &#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  return new F();</span><br><span class="line">&#125;</span><br><span class="line">缺点：</span><br><span class="line">-  和原型链继承一样，所有子类实例共享父类的引用类型</span><br></pre></td></tr></table></figure><p><strong>寄生式继承</strong></p><p><code>寄生式继承是与原型式继承紧密相关的一种思路，创建一个仅用于封装继承过程的函数，该函数内部以某种形式来做增强对象，最后返回对象</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function object (o) &#123;</span><br><span class="line">  function F() &#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createAnother (o) &#123;</span><br><span class="line">  var clone = object(o);</span><br><span class="line">  clone.sayHi = function () &#123;</span><br><span class="line">    console.log(&apos;Hi&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  return clone;</span><br><span class="line">&#125;</span><br><span class="line">缺点：</span><br><span class="line">1,和原型链式继承一样，所有子类实例共享父类引用类型。</span><br><span class="line">2,和借用构造函数继承一样，每次创建对象都会创建一次方法</span><br></pre></td></tr></table></figure><p><strong>寄生组合式继承</strong></p><p><code>结合组合式继承和寄生式继承，解决组合式继承调用两次父类构造函数的问题</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function object(o) &#123;</span><br><span class="line">  function F() &#123; &#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function inheritPrototype(SubType, SuperType) &#123;</span><br><span class="line">  var prototype = object(SuperType.prototype);        // 创建对象</span><br><span class="line">  prototype.constructor = SubType;    // 增强对象</span><br><span class="line">  SubType.prototype = prototype;      // 指定对象 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 父类</span><br><span class="line">function SuperType(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = function () &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line">  // 继承父类实例属性</span><br><span class="line">  SuperType.call(this, name);</span><br><span class="line"></span><br><span class="line">  // 子类实例属性</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 继承父类方法</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br></pre></td></tr></table></figure><p><strong>Es6继承</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function object(o) &#123;</span><br><span class="line">  function F() &#123; &#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function inheritPrototype(SubType, SuperType) &#123;</span><br><span class="line">  var prototype = object(SuperType.prototype);        // 创建对象</span><br><span class="line">  prototype.constructor = SubType;    // 增强对象</span><br><span class="line">  SubType.prototype = prototype;      // 指定对象 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 父类</span><br><span class="line">function SuperType(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = function () &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line">  // 继承父类实例属性</span><br><span class="line">  SuperType.call(this, name);</span><br><span class="line"></span><br><span class="line">  // 子类实例属性</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 继承父类方法</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br></pre></td></tr></table></figure><blockquote><p>底层也是用寄生组合式继承实现的</p></blockquote><p><strong>拷贝继承</strong><br><code>把一个对象中的属性和方法复制到另一个</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">浅拷贝</span><br><span class="line"> function shallowCopy(source, target = &#123;&#125;) &#123;</span><br><span class="line">        var key;</span><br><span class="line">        for (key in source) &#123;</span><br><span class="line">            if (source.hasOwnProperty(key)) &#123;        // 意思就是__proto__上面的属性,我不拷贝</span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">深拷贝 </span><br><span class="line">（对象里面嵌套对象才涉及深拷贝）</span><br><span class="line">function deepCopy(source, target = &#123;&#125;) &#123;</span><br><span class="line">        var key;</span><br><span class="line">        for (key in source) &#123;</span><br><span class="line">            if (source.hasOwnProperty(key)) &#123;                         // 意思就是__proto__上面的属性,我不拷贝</span><br><span class="line">                if (typeof(source[key]) === &quot;object&quot;) &#123;               // 如果这一项是object类型,就递归调用deepCopy</span><br><span class="line">                    target[key] = Array.isArray(source[key]) ? [] : &#123;&#125;;</span><br><span class="line">                    deepCopy(source[key], target[key]);</span><br><span class="line">                &#125; else &#123;                                            // 如果不是object类型,就直接赋值拷贝</span><br><span class="line">                    target[key] = source[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p><strong>深拷贝黑科技</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var targetObj = JSON.parse(JSON.stringify(copyObj))</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">1、如果你的对象里有函数,函数无法被拷贝下来</span><br><span class="line">2、无法拷贝copyObj对象原型链上的属性和方法</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Event Loop</title>
    <link href="http://yoursite.com/2018/08/18/Event%20Loop/"/>
    <id>http://yoursite.com/2018/08/18/Event Loop/</id>
    <published>2018-08-18T14:47:30.000Z</published>
    <updated>2019-08-22T13:02:25.944Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JavaScript的事件分两种，宏任务-macro-task-和微任务-micro-task"><a href="#JavaScript的事件分两种，宏任务-macro-task-和微任务-micro-task" class="headerlink" title="JavaScript的事件分两种，宏任务(macro-task)和微任务(micro-task)"></a>JavaScript的事件分两种，宏任务(macro-task)和微任务(micro-task)</h3><ul><li>宏任务：包括整体代码script，setTimeout，setInterval</li><li>微任务：Promise.then(非new Promise)，process.nextTick(node中)</li></ul><blockquote><p>事件的执行顺序，是先执行宏任务，然后执行微任务，这个是基础，任务可以有同步任务和异步任务，同步的进入主线程，异步的进入Event Table并注册函数，异步事件完成后，会将回调函数放入Event Queue中(宏任务和微任务是不同的Event Queue)，同步任务执行完成后，会从Event Queue中读取事件放入主线程执行，回调函数中可能还会包含不同的任务，因此会循环执行上述操作。<br>``</p></blockquote><a id="more"></a><p>setTimeout(() =&gt; {<br>    console.log(‘延时1秒’);<br>},1000)<br>console.log(“开始”)<br>输出：<br>开始<br>延时1秒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`上述代码，setTimeout函数是宏任务，且是异步任务，因此会将函数放入Event Table并注册函数，经过指定时间后，把要执行的任务加入到Event Queue中，等待同步任务console.log(&quot;开始&quot;)执行结束后，读取Event Queue中setTimeout的回调函数执行。`</span><br><span class="line"></span><br><span class="line">上述代码不包含微任务，接下来看包含微任务的代码：</span><br></pre></td></tr></table></figure><p>setTimeout(function() {<br>    console.log(‘setTimeout’);<br>},1000)</p><p>new Promise(function(resolve) {<br>    console.log(‘promise’);<br>}).then(function() {<br>    console.log(‘then’);<br>})</p><p>console.log(‘console’);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">`首先setTimeout，放入Event Table中，1秒后将回调函数放入宏任务的Event Queue中</span><br><span class="line">new Promise 同步代码，立即执行console.log(&apos;promise&apos;),然后看到微任务then，因此将其放入微任务的Event Queue中</span><br><span class="line">接下来执行同步代码console.log(&apos;console&apos;)</span><br><span class="line">主线程的宏任务，已经执行完毕，接下来要执行微任务，因此会执行Promise.then，到此，第一轮事件循环执行完毕</span><br><span class="line">第二轮事件循环开始，先执行宏任务，即setTimeout的回调函数，然后查找是否有微任务，没有，时间循环结束`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 到此做个总结，事件循环，先执行宏任务，其中同步任务立即执行，异步任务，加载到对应的的Event Queue中(setTimeout等加入宏任务的Event Queue，Promise.then加入微任务的Event Queue)，所有同步宏任务执行完毕后，如果发现微任务的Event Queue中有未执行的任务，会先执行其中的任务，这样算是完成了一次事件循环。接下来查看宏任务的Event Queue中是否有未执行的任务，有的话，就开始第二轮事件循环，依此类推。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上述例子只是简单的一层嵌套，接下来看一个稍微复杂了一点点的例子：</span><br></pre></td></tr></table></figure><p>console.log(‘1’);<br>setTimeout(function() {<br>    console.log(‘2’);<br>    process.nextTick(function() {<br>        console.log(‘3’);<br>    })<br>    new Promise(function(resolve) {<br>        console.log(‘4’);<br>        resolve();<br>    }).then(function() {<br>        console.log(‘5’)<br>    })<br>})<br>输出：<br>1<br>2<br>4<br>3<br>5</p><pre><code>`宏任务同步代码console.log(&apos;1&apos;),不多说setTimeout，加入宏任务Event Queue，没有发现微任务，第一轮事件循环走完第二轮事件循环开始，先执行宏任务，从宏任务Event Queue中独取出setTimeout的回调函数同步代码console.log(&apos;2&apos;),发现process.nextTick，加入微任务Event Queuenew Promise，同步执行console.log(&apos;4&apos;),发现then，加入微任务Event Queue宏任务执行完毕，接下来执行微任务，先执行process.nextTick，然后执行Promise.then微任务执行完毕，第二轮事件循环走完，没有发现宏任务，事件循环结束`</code></pre>]]></content>
    
    <summary type="html">
    
      附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
