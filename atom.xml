<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘晓儒个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-22T13:47:08.292Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>刘晓儒</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>原型和原型链</title>
    <link href="http://yoursite.com/2019/08/22/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2019/08/22/原型和原型链/</id>
    <published>2019-08-22T13:46:39.000Z</published>
    <updated>2019-08-22T13:47:08.292Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>还是接着上面的示例，如果执行<code>f.toString()</code>时，又发生了什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 省略 N 行</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">f.printName()</span><br><span class="line">f.alertName()</span><br><span class="line">f.toString()</span><br></pre></td></tr></table></figure><p>因为<code>f</code>本身没有<code>toString()</code>，并且<code>f.__proto__</code>（即<code>Foo.prototype</code>）中也没有<code>toString</code>。这个问题还是得拿出刚才那句话——<strong>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的<code>__proto__</code>（即它的构造函数的<code>prototype</code>）中寻找</strong>。</p><p>如果在<code>f.__proto__</code>中没有找到<code>toString</code>，那么就继续去<code>f.__proto__.__proto__</code>中寻找，因为<code>f.__proto__</code>就是一个普通的对象而已嘛！</p><ul><li><code>f.__proto__</code>即<code>Foo.prototype</code>，没有找到<code>toString</code>，继续往上找</li><li><code>f.__proto__.__proto__</code>即<code>Foo.prototype.__proto__</code>。<code>Foo.prototype</code>就是一个普通的对象，因此<code>Foo.prototype.__proto__</code>就是<code>Object.prototype</code>，在这里可以找到<code>toString</code></li><li>因此<code>f.toString</code>最终对应到了<code>Object.prototype.toString</code></li></ul><p>这样一直往上找，你会发现是一个链式的结构，所以叫做“原型链”。如果一直找到最上层都没有找到，那么就宣告失败，返回<code>undefined</code>。最上层是什么 —— <code>Object.prototype.__proto__ === null</code></p><h3 id="原型链中的this"><a href="#原型链中的this" class="headerlink" title="原型链中的this"></a>原型链中的<code>this</code></h3><p>所有从原型或更高级原型中得到、执行的方法，其中的<code>this</code>在执行时，就指向了当前这个触发事件执行的对象。因此<code>printName</code>和<code>alertName</code>中的<code>this</code>都是<code>f</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;原型链&quot;&gt;&lt;a href=&quot;#原型链&quot; class=&quot;headerlink&quot; title=&quot;原型链&quot;&gt;&lt;/a&gt;原型链&lt;/h3&gt;&lt;p&gt;还是接着上面的示例，如果执行&lt;code&gt;f.toString()&lt;/code&gt;时，又发生了什么？&lt;/p&gt;
&lt;figure class
      
    
    </summary>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>模块化进化史</title>
    <link href="http://yoursite.com/2019/08/22/%E6%A8%A1%E5%9D%97%E5%8C%96%E8%BF%9B%E5%8C%96%E5%8F%B2/"/>
    <id>http://yoursite.com/2019/08/22/模块化进化史/</id>
    <published>2019-08-22T13:37:15.000Z</published>
    <updated>2019-08-22T13:38:08.494Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模块化的理解"><a href="#模块化的理解" class="headerlink" title="模块化的理解"></a>模块化的理解</h3><p>将一个复杂的程序按一定规则拆分成几个块，块与块内部实现是私有的，相互独立，只是向外暴露指定方法与外部其他块通信</p><h5 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h5><ul><li>避免命名冲突</li><li>更好的分离，按需加载</li><li>更高的复用性</li><li>更高的可维护性<a id="more"></a></li></ul><h3 id="模块的进化"><a href="#模块的进化" class="headerlink" title="模块的进化"></a>模块的进化</h3><h4 id="1-全局function模式：将不同功能封装成全局函数"><a href="#1-全局function模式：将不同功能封装成全局函数" class="headerlink" title="1.全局function模式：将不同功能封装成全局函数"></a>1.全局function模式：将不同功能封装成全局函数</h4><p>问题：污染全局命名空间，容易引起命名冲突，而且模块之间看不出直接关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function m1()&#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line">function m2()&#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-namespace模式-简单对象封装"><a href="#2-namespace模式-简单对象封装" class="headerlink" title="2.namespace模式 : 简单对象封装"></a>2.namespace模式 : 简单对象封装</h4><p>作用：减少了全局变量<br>问题：数据不安全（外部可以直接修改模块内变量）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let myModule = &#123;</span><br><span class="line">  data: &apos;www.baidu.com&apos;,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    console.log(`foo(this.data)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">myModule.data = &apos;other data&apos; //能直接修改模块内部的数据</span><br><span class="line">myModule.foo() // foo() other data</span><br></pre></td></tr></table></figure><h4 id="3-IIFE模式：匿名函数自调用-闭包"><a href="#3-IIFE模式：匿名函数自调用-闭包" class="headerlink" title="3.IIFE模式：匿名函数自调用(闭包)"></a>3.IIFE模式：匿名函数自调用(闭包)</h4><p>作用：模块是私有的，外部只能通过暴露的接口访问<br>编码：通过添加window的属性暴露接口<br>问题：如果依赖其他模块，在引用模块的时候顺序要求严格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// module.js文件</span><br><span class="line">(function(window, $) &#123;</span><br><span class="line">  let data = &apos;www.baidu.com&apos;</span><br><span class="line">  //操作数据的函数</span><br><span class="line">  function foo() &#123;</span><br><span class="line">    //用于暴露有函数</span><br><span class="line">    console.log(`foo() $&#123;data&#125;`)</span><br><span class="line">    $(&apos;body&apos;).css(&apos;background&apos;, &apos;red&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  function bar() &#123;</span><br><span class="line">    //用于暴露有函数</span><br><span class="line">    console.log(`bar() $&#123;data&#125;`)</span><br><span class="line">    otherFun() //内部调用</span><br><span class="line">  &#125;</span><br><span class="line">  function otherFun() &#123;</span><br><span class="line">    //内部私有的函数</span><br><span class="line">    console.log(&apos;otherFun()&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  //暴露行为</span><br><span class="line">  window.myModule = &#123; foo, bar &#125;</span><br><span class="line">&#125;)(window, jQuery)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line">  &lt;!-- 引入的js必须有一定顺序 --&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.10.1.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    myModule.foo()</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="4-模块化规范"><a href="#4-模块化规范" class="headerlink" title="4.模块化规范"></a>4.模块化规范</h4><ul><li>CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本语法</span><br><span class="line">暴露模块：module.exports = value或exports.xxx = value</span><br><span class="line">引入模块：require(xxx),如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径</span><br></pre></td></tr></table></figure><ul><li>AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">定义暴露模块:</span><br><span class="line"></span><br><span class="line">//定义没有依赖的模块</span><br><span class="line">define(function()&#123;</span><br><span class="line">   return 模块</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//定义有依赖的模块</span><br><span class="line">define([&apos;module1&apos;, &apos;module2&apos;], function(m1, m2)&#123;</span><br><span class="line">   return 模块</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">引入使用模块:</span><br><span class="line">require([&apos;module1&apos;, &apos;module2&apos;], function(m1, m2)&#123;</span><br><span class="line">   使用m1/m2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">定义暴露模块：</span><br><span class="line"></span><br><span class="line">//定义没有依赖的模块</span><br><span class="line">define(function(require, exports, module)&#123;</span><br><span class="line">  exports.xxx = value</span><br><span class="line">  module.exports = value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//定义有依赖的模块</span><br><span class="line">define(function(require, exports, module)&#123;</span><br><span class="line">  //引入依赖模块(同步)</span><br><span class="line">  var module2 = require(&apos;./module2&apos;)</span><br><span class="line">  //引入依赖模块(异步)</span><br><span class="line">    require.async(&apos;./module3&apos;, function (m3) &#123;</span><br><span class="line">    &#125;)</span><br><span class="line">  //暴露模块</span><br><span class="line">  exports.xxx = value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">引入使用模块：</span><br><span class="line"></span><br><span class="line">define(function (require) &#123;</span><br><span class="line">  var m1 = require(&apos;./module1&apos;)</span><br><span class="line">  var m4 = require(&apos;./module4&apos;)</span><br><span class="line">  m1.show()</span><br><span class="line">  m4.show()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</span><br><span class="line"></span><br><span class="line">/** 定义模块 math.js **/</span><br><span class="line">var basicNum = 0;</span><br><span class="line">var add = function (a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;;</span><br><span class="line">export &#123; basicNum, add &#125;;</span><br><span class="line">/** 引用模块 **/</span><br><span class="line">import &#123; basicNum, add &#125; from &apos;./math&apos;;</span><br><span class="line">function test(ele) &#123;</span><br><span class="line">    ele.textContent = add(99 + basicNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default命令，为模块指定默认输出。</span><br><span class="line">// export-default.js</span><br><span class="line">export default function () &#123;</span><br><span class="line">  console.log(&apos;foo&apos;);</span><br><span class="line"></span><br><span class="line">// import-default.js</span><br><span class="line">import customName from &apos;./export-default&apos;;</span><br><span class="line">customName(); // &apos;foo&apos;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;模块化的理解&quot;&gt;&lt;a href=&quot;#模块化的理解&quot; class=&quot;headerlink&quot; title=&quot;模块化的理解&quot;&gt;&lt;/a&gt;模块化的理解&lt;/h3&gt;&lt;p&gt;将一个复杂的程序按一定规则拆分成几个块，块与块内部实现是私有的，相互独立，只是向外暴露指定方法与外部其他块通信&lt;/p&gt;
&lt;h5 id=&quot;模块化的好处&quot;&gt;&lt;a href=&quot;#模块化的好处&quot; class=&quot;headerlink&quot; title=&quot;模块化的好处&quot;&gt;&lt;/a&gt;模块化的好处&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;避免命名冲突&lt;/li&gt;
&lt;li&gt;更好的分离，按需加载&lt;/li&gt;
&lt;li&gt;更高的复用性&lt;/li&gt;
&lt;li&gt;更高的可维护性
    
    </summary>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>http协议基础（下)</title>
    <link href="http://yoursite.com/2018/08/21/http%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%E4%B8%8B/"/>
    <id>http://yoursite.com/2018/08/21/http协议基础下/</id>
    <published>2018-08-21T14:20:47.000Z</published>
    <updated>2019-08-22T13:40:38.771Z</updated>
    
    <content type="html"><![CDATA[<p><strong>http状态码</strong></p><blockquote><ul><li>1XX:接收信息正在处理</li><li>2XX:正常处理完毕（200请求成功）</li></ul></blockquote><a id="more"></a><blockquote><ul><li>3XX:重定向<ul><li>301 永久重定向</li><li>302 临时重定向</li></ul></li><li>4XX:客户端错误<ul><li>400:语法错误（参数不对）</li><li>401:未认证</li><li>403:禁止访问</li><li>404:资源未找到</li></ul></li><li>5XX:服务器错误<ul><li>500:服务器出错</li><li>503:服务器繁忙</li></ul></li></ul></blockquote><p><strong>HTTP首部字段</strong></p><blockquote><p><em>通用首部字段</em></p><ul><li>Cach-Control 控制缓存的行为</li><li>Date 创建报文的事件</li><li>Connection 连接管理</li><li>Pragma：报文指令</li><li>Trailer：报文末端的首部一览</li><li>Transfer-Encoding：指定报文主体的传输编码方式</li><li>Upgrade：升级为其他协议</li><li>Via：代理服务器的相关信息</li><li>Warning：错误通知</li></ul></blockquote><blockquote><p><em>请求首部字段（Request Header Fields）</em></p><ul><li>从客户端向服务器发送求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</li><li>Accept：用户代理可处理的媒体类型</li><li>Accept-Charset：优先的字符集</li><li>Accept-Encoding：优先的内容编码</li><li>Accept-Language：优先的语言（自然语言）</li><li>Authorization：Web认证信息</li><li>Expect：期待服务器的特定行为</li><li>From：用户的电子邮箱地址</li><li>Host：请求资源所在服务器</li><li>If-Match：比较实体标记（ETag）</li><li>If-Modified-Since：比较资源的更新时间</li><li>If-None-Match：比较实体标记（与If-Match相反）</li><li>If-Range：资源未更新时发送实体Byte的范围请求</li><li>If-Unmodified-Since：比较资源的更新时间（与If-Modified-Since相反）</li><li>Max-Forwards：最大传输逐跳数</li><li>Proxy-Authorization：代理服务器要求客户端的认真信息</li><li>Range：实体的直接范围请求</li><li>Referer：对请求中URI的原始获取方</li><li>TE：传输编码的优先级</li><li>User-Agent：HTTP客户端程序的信息</li></ul></blockquote><blockquote><p><em>响应首部字段（Response Header Fields）</em></p><ul><li>从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会请求客户端附加额外的内容信息。</li><li>Accept-Ranges：是否接受字节范围请求</li><li>Age：推算资源创建经过时间</li><li>ETag：资源的匹配信息</li><li>Location：令客户端重定向至指定URI</li><li>Proxy-Authenticate：代理服务器对客户端的认真信息</li><li>Retry-After：对再次发起请求的时机请求</li><li>Server：HTTP服务器的安装信息</li><li>Vary：代理服务器缓存的管理信息</li><li>WWW-Authenticate：服务器对客户端的认真信息</li></ul></blockquote><blockquote><p><em>实体首部字段（Entity Header Fields）</em><br>针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体相关的信息。</p></blockquote><ul><li>Allow：资源可支持的HTTP方法</li><li>Content-Encoding：实体主体适用的编码方法</li><li>Content-Language：实体主体的自然语言</li><li>Content-Length：实体主体的大小（单位：字节）</li><li>Content-Location：替代对应资源的URI</li><li>Content-MD5：实体主体的报文摘要</li><li>Content-Range：实体主体的位置范围</li><li>Content-Type：实体主体的媒体类型</li><li>Expires：实体主体过期的日期时间</li><li>Last-Modified：资源的最后修改日期时间</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;http状态码&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1XX:接收信息正在处理&lt;/li&gt;
&lt;li&gt;2XX:正常处理完毕（200请求成功）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存机制</title>
    <link href="http://yoursite.com/2018/08/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/08/21/浏览器缓存机制/</id>
    <published>2018-08-21T12:29:58.000Z</published>
    <updated>2019-08-22T13:02:15.863Z</updated>
    
    <content type="html"><![CDATA[<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>浏览器缓存机制是“通过 HTTP 协议 header 里的Cache-Control（或Expires）和Last-Modified（或Etag）等字段来控制文件缓存的机制”</p><a id="more"></a><h4 id="使用缓存的优点"><a href="#使用缓存的优点" class="headerlink" title="使用缓存的优点"></a>使用缓存的优点</h4><ul><li>减小网络带宽消耗</li><li>降低服务器压力</li><li>减小网络延迟，加快页面打开速度</li></ul><h4 id="浏览器缓存规则"><a href="#浏览器缓存规则" class="headerlink" title="浏览器缓存规则"></a>浏览器缓存规则</h4><p>新鲜度（过期机制）：缓存副本有效期</p><p>校验值（校验机制）：缓存实体标签etag</p><h4 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h4><p><strong>首次请求</strong></p><blockquote><p>这时候浏览器端是 没有缓存 的，所以会直接向服务器发送请求，且 不携带任何缓存相关参数，服务器接收到资源请求时，会在响应头中加入如下 参数(注意：这些参数对于浏览器而言是有优先级的！且对应着“浏览器端不同的缓存策略”)</p><ul><li>Expires：服务端设置的一个“资源过期时间”，但是因为客户端和服务端时间有误差，会导致缓存命中的误差，因此优先级较低</li><li>Cache-Control：控制缓存的行为，一般取值有 private（默认）、public、no-cache、max-age，no-store，但我们一般常见的值是 max-age，缓存的内容将在多少秒后失效</li><li>Last-Modified：资源的最后修改时间。</li><li>ETag：资源在服务器的唯一标识（生成规则由服务器决定，例如内容的hash值）</li></ul></blockquote><blockquote><p>对于浏览器接收到这些头参数的优先级是：Cache-Control &gt; Expires &gt; ETag &gt; Last-Modified,至此,服务端就将携带缓存头参数的信息返回给了浏览器，浏览器接收之后,一方面解析加载到浏览器上，另一方面会存储下来</p></blockquote><p><strong>再次请求</strong></p><blockquote><ul><li>先判断本地是否有缓存，没有的话，就回到第一次请求的流程</li><li>判断缓存是否过期,如果没过期,不需要发出请求，直接使用缓存资源即可,<strong>所谓强缓存</strong></li><li>如果过期了就会检查 <code>ETag</code> 和 <code>Last-Modified</code> 这两个参数，无论如何都会再次向服务器发出请求，ETag 对应头参数 <code>If-None-Match</code>，<code>Last-Modified</code> 对应头参数 <code>If-Modified-Since</code>，前者优先级更高，向服务端发起携带缓存头参数<code>If-None-Match</code> 和<code>If-Modified-Since</code>的请求后，服务端会决策浏览器端缓存的资源是否是最新的。如果是,就会返回只带响应头的响应报文，且状态码是我们常见的<code>304</code>。<strong>即协商缓存</strong>否则就会和第一次请求一样，重新返回最新的资源。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h4&gt;&lt;p&gt;浏览器缓存机制是“通过 HTTP 协议 header 里的Cache-Control（或Expires）和Last-Modified（或Etag）等字段来控制文件缓存的机制”&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>options请求是什么鬼</title>
    <link href="http://yoursite.com/2018/08/20/options/"/>
    <id>http://yoursite.com/2018/08/20/options/</id>
    <published>2018-08-20T15:06:00.000Z</published>
    <updated>2019-08-22T13:02:41.849Z</updated>
    
    <content type="html"><![CDATA[<p>options出现的情况只有两种：</p><blockquote><ul><li>1、获取目的资源所支持的通信方式<br>黑客有可能经常用到这个；在响应报文中包含一个Allow首部字段，该字段的值表明了服务器支持的所有HTTP方法，如下：</li><li>2、跨域请求中，options请求是浏览器自发起的preflight request(预检请求)，以检测实际请求是否可以被浏览器接受.</li></ul></blockquote><a id="more"></a><p>在我们开发过程中出现的浏览器自发起的options请求就是上面的第二种情况。实际上，跨域请求中的”复杂请求”发出前会进行一次方法是options的preflight request。</p><p>符合以下任一情况的就是复杂请求：</p><blockquote><p>1.使用方法put或者delete;<br>2.发送json格式的数据（content-type: application/json）<br>3.请求中带有自定义头部；</p></blockquote><p>为什么跨域的复杂请求需要preflight request？</p><blockquote><p>复杂请求可能对服务器数据产生副作用。例如delete或者put,都会对服务器数据进行修改,所以在请求之前都要先询问服务器，当前网页所在域名是否在服务器的许可名单中，服务器允许后，浏览器才会发出正式的请求，否则不发送正式请求。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;options出现的情况只有两种：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1、获取目的资源所支持的通信方式&lt;br&gt;黑客有可能经常用到这个；在响应报文中包含一个Allow首部字段，该字段的值表明了服务器支持的所有HTTP方法，如下：&lt;/li&gt;
&lt;li&gt;2、跨域请求中，options请求是浏览器自发起的preflight request(预检请求)，以检测实际请求是否可以被浏览器接受.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>Referer</title>
    <link href="http://yoursite.com/2018/08/20/reffer/"/>
    <id>http://yoursite.com/2018/08/20/reffer/</id>
    <published>2018-08-20T14:55:51.000Z</published>
    <updated>2019-08-22T13:02:47.245Z</updated>
    
    <content type="html"><![CDATA[<p>Referer  是  HTTP  请求header 的一部分，当浏览器（或者模拟浏览器行为）向web 服务器发送请求的时候，头信息里有包含  Referer  。比如我在<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 里有一个<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 链接，那么点击这个<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> ，它的header 信息里就有：<code>Referer=http://www.google.com</code>它就是表示一个来源。</p><a id="more"></a><p><strong>Referer的作用？</strong></p><blockquote><ul><li>1.防盗链。<br>比如我只允许我自己的网站访问我自己的图片服务器，那我的域名是<a href="http://www.google.com，" target="_blank" rel="noopener">www.google.com，</a> 那么图片服务器每次取到Referer来判断一下是不是我自己的域名<a href="http://www.google.com，" target="_blank" rel="noopener">www.google.com，</a> 如果是就继续访问，不是就拦截。</li><li>防止恶意请求(CSRF).</li></ul></blockquote><p><strong>空Referer是怎么回事</strong></p><blockquote><p>直接在浏览器的地址栏中输入一个资源的URL地址，那么这种请求是不会包含 Referer  字段的，因为这是一个“凭空产生”的 HTTP  请求，并不是从一个地方链接过去的</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Referer  是  HTTP  请求header 的一部分，当浏览器（或者模拟浏览器行为）向web 服务器发送请求的时候，头信息里有包含  Referer  。比如我在&lt;a href=&quot;http://www.google.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.google.com&lt;/a&gt; 里有一个&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.baidu.com&lt;/a&gt; 链接，那么点击这个&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.baidu.com&lt;/a&gt; ，它的header 信息里就有：&lt;code&gt;Referer=http://www.google.com&lt;/code&gt;它就是表示一个来源。&lt;/p&gt;
    
    </summary>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>http协议基础（上）</title>
    <link href="http://yoursite.com/2018/08/20/http%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/08/20/http协议基础/</id>
    <published>2018-08-20T13:50:49.000Z</published>
    <updated>2019-08-22T13:02:09.828Z</updated>
    
    <content type="html"><![CDATA[<p><strong>什么是Http协议</strong></p><blockquote><p>超文本传输协议，是一个应用层协议，通过浏览器和服务器进行数据交互，进行超文本（文本、图片、视频等）传输的规定。</p></blockquote><a id="more"></a><p><strong>http协议结构组成</strong></p><blockquote><p>请求行（包括url，请求方式，状态码，http协议版本）<br>请求头<br>请求体</p></blockquote><p><strong>http协议中有哪些请求方式</strong></p><blockquote><p>GET:用于请求访问已经被URI(统一资源标识符)识别的资源,可以通过URL传参给服务器<br>POST:用于传输信息给服务器,主要功能与GET方法类似,但一般推荐使用POST方式<br>PUT:传输文件,报文主体中包含文件内容,保存到对应URI位置<br>HEAD:获得报文首部,与GET方法类似,只是不返回报文主体,一般用于验证URI是否有效<br>DELETE:删除文件,与PUT方法相反,删除对应URI位置的文件<br>OPTIONS:查询响应URI支持的HTTP方法</p></blockquote><p><strong>GET和POST的区别</strong></p><blockquote><ul><li>get重点在从服务器上获取资源,post重点在想服务器发送数据;</li><li>get传输数据是通过URL请求,以filed(字段)=value的形式,置于URL后,并用”?”连接,多个请求数据之间用<br>“&amp;”连接,这个过程用户是可见的,post是放在请求体内</li><li>get传输量小,因为受URL长度限制,但效率较低/post可以传输大量数据,所以上传文件时只能用post方式</li><li>get是不安全的,因为URL是可见的,可能会泄露私密信息,如密码等</li></ul></blockquote><p><strong>HTTP和https区别</strong></p><blockquote><ul><li>https协议需要到ca申请证书，一般免费证书很少，需要交费。</li><li>http是超文本传输协议，信息是明文传输，https 则是具有安全性的<code>ssl</code>加密传输协议。</li><li>http和https使用的是完全不同的连接方式用的端口也不一样，前者是80，后者是443。</li><li>http的连接很简单，是无状态的。HTTPS协议是由<code>SSL+HTTP</code>协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</li></ul></blockquote><p><strong>http1.0和http1.1区别</strong></p><blockquote><ul><li>建立连接方面: HTTP/1.0 每次请求都需要建立新的TCP连接，连接不能复用。HTTP/1.1 新的请求可以在上次请求建立的TCP连接之上发送，连接可以复用。优点是减少重复进行TCP三次握手的开销，提高效率。</li><li>HTTP1.1增加了<code>OPTIONS</code>, <code>PUT</code>, <code>DELETE,</code> <code>TRACE</code>, <code>CONNECT</code>这些Request方法</li></ul></blockquote><p> <strong>无状态</strong></p><blockquote><p>由于http是一种无状态的协议，因此无论是客户端还是服务器都不记录http的相关信息。这样设计一方面减轻了服务器端的负载，另一方面减小了http请求的开销。<br><code>cookie</code>和<code>session</code>用于解决http无状态的问题</p></blockquote><p><strong>持久化</strong></p><blockquote><p>正常在发送http时，都需要建立<code>TCP</code>的连接，再发送报文,　如果每次想要发送http报文都需要经过这个过程，那么时间大部分都会消耗在建立和断开连接的过程中。因此http中使用了<code>connection</code>属性，用于指定连接的方式。当设置成<code>keep-alive</code>，就会建立一条持久化的连接。不需要每次都建立连接，再中断。</p></blockquote><p><strong>管道化</strong></p><blockquote><p>http可以一次发送多个http请求，然后等待响应连接。不需要排队等候，这样就加快了http的响应时间。</p></blockquote><p><strong>内容编码</strong></p><blockquote><p>由于某些报文的内容过大，因此在传输时，为了减少传输的时间，会采取一些压缩的措施。例如<code>accept-Encoding</code>定义了内容编码的格式：<code>gzip</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;什么是Http协议&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;超文本传输协议，是一个应用层协议，通过浏览器和服务器进行数据交互，进行超文本（文本、图片、视频等）传输的规定。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="http协议" scheme="http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>前端安全防御</title>
    <link href="http://yoursite.com/2018/08/19/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%98%B2%E5%BE%A1/"/>
    <id>http://yoursite.com/2018/08/19/前端安全防御/</id>
    <published>2018-08-19T12:27:35.000Z</published>
    <updated>2019-08-22T13:02:20.511Z</updated>
    
    <content type="html"><![CDATA[<p><strong>CSRF（Cross Site Request Forgy）跨站请求伪造</strong></p><blockquote><p>原理：在第三方网站向本网站发请求<br>（1）用户在a站前端页面发起登录（身份认证）请求<br>（2）a站后端确认身份，登录成功，cookie中存在用户的身份认证信息<br>（3）b站前端页面向a站后端发起请求，带着a站的cookie信息（身份认证信息），请求成功</p></blockquote><a id="more"></a><blockquote><p>特点：<br>b站发送的请求带着a站的cookie信息；<br>b站发送请求不经过a站的前端；<br>http请求头中的referer为b站</p></blockquote><blockquote><p>防御：<br>（1）禁止第三方网站携带本网站的cookie信息：设置same-site属性，same-site属性有两个值，Strict（所有的第三方请求都不能携带本网站的cookie）和Lax（链接可以，但是form表单提交和ajax请求不行）<br>（2）本网站前端页面添加验证信息：使用验证码或者添加token验证<br>（3）referer验证：禁止来自第三方的请求</p></blockquote><p><strong>XSS（Cross Site Scripting）跨站脚本攻击</strong></p><blockquote><p>(1）原理：页面渲染的数据中包含可运行的脚本<br>(2）攻击的基本类型：反射型（url参数直接注入）和存储型（存储到DB后读取时注入）<br>(3）注入点：HTML节点内的内容（text）；HTML中DOM元素的属性；Javascript代码；富文本</p></blockquote><blockquote><p>如何防御<br>（1）浏览器自带防御机制，主要应对反射型攻击（HTML内容或属性）：http响应头中自动添加x-xss-protection，值为0（关闭），1（打开），默认打开<br>（2）对特定字符做转义：内容注入替换尖括号（ &lt; =&gt; &lt;   &gt; =&gt; &gt; ） 属性注入替换单引号或双引号（ “ =&gt; &quot;  ‘ =&gt; &#39; ）<br>（3）CSP（Content Security Policy）内容安全策略：用于指定哪些内容可执行</p></blockquote><p><strong>点击劫持</strong></p><blockquote><p>原理：<br>第三方网站通过iframe内嵌某一个网站，并且将iframe设置为透明不可见，将其覆盖在其他经过伪装的DOM上，伪装的可点击DOM（按钮等）与实际内嵌网站的可点击DOM位置相同，当用户点击伪装的DOM时，实际上点击的是iframe中内嵌的网页的DOM从而触发请求操作</p></blockquote><blockquote><p>特点：<br>用户自己做了点击操作；用户毫不知情；</p></blockquote><blockquote><p>防御<br>Javascript禁止内嵌：当网页没有被使用iframe内嵌时，top和window是相等的；当网页被内嵌时，top和window是不相等的；可以在本网站的页面中添加如下判断</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;CSRF（Cross Site Request Forgy）跨站请求伪造&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原理：在第三方网站向本网站发请求&lt;br&gt;（1）用户在a站前端页面发起登录（身份认证）请求&lt;br&gt;（2）a站后端确认身份，登录成功，cookie中存在用户的身份认证信息&lt;br&gt;（3）b站前端页面向a站后端发起请求，带着a站的cookie信息（身份认证信息），请求成功&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="前端安全防御" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%98%B2%E5%BE%A1/"/>
    
  </entry>
  
  <entry>
    <title>JS继承的继承方式</title>
    <link href="http://yoursite.com/2018/08/19/JS%E7%BB%A7%E6%89%BF%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/08/19/JS继承的继承方式/</id>
    <published>2018-08-18T18:08:57.000Z</published>
    <updated>2019-08-22T13:02:36.643Z</updated>
    
    <content type="html"><![CDATA[<p><strong>原型链继承</strong></p><p><code>利用prototype将子构造函数的prototype指向Person达到继承的目的</code>；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.country=&apos;china&apos;;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.play = function()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child(age)&#123;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = new Person();</span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li><code>创建子类实例时，但是无法给父构造函数传参</code></li><li><code>来自原型对象的引用属性是所有实例共享的</code></li></ul><a id="more"></a><p><strong>构造函数继承</strong></p><p><code>在子类构造函数中借用call调用父类构造函数</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.country=&apos;china&apos;;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.play = function()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child(name,age)&#123;</span><br><span class="line">    this.age = age;</span><br><span class="line">    Person.call(this,name)</span><br><span class="line">&#125;</span><br><span class="line">var obj = new Child(&apos;小明&apos;，16);</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li><code>解决了子类构造函数向父类构造函数传参数和实例共享原型属性的问题</code></li></ul><p>缺点：</p><ul><li><code>相当于每个实例都拷贝了一份父类的方法，占用内存大</code></li><li><code>不能继承原型属性/方法，只能继承父类的实例属性和方法</code></li></ul><p><strong>组合继承</strong></p><p><code>使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.country=&apos;china&apos;;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.play = function()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">function Child(name,age)&#123;</span><br><span class="line">    Person.call(this,name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = new Person();</span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li><code>会调用两次父类构造函数</code></li><li></li></ul><p><strong>原型式继承</strong></p><p><code>基于已有对象，创建新对象</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 在object函数内部，先创建了一个临时的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个新实例。</span><br><span class="line">// 从本质上讲，object()对传入其中的对象执行了一次浅复制。</span><br><span class="line"></span><br><span class="line">function object (o) &#123;</span><br><span class="line">  function F() &#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  return new F();</span><br><span class="line">&#125;</span><br><span class="line">缺点：</span><br><span class="line">-  和原型链继承一样，所有子类实例共享父类的引用类型</span><br></pre></td></tr></table></figure><p><strong>寄生式继承</strong></p><p><code>寄生式继承是与原型式继承紧密相关的一种思路，创建一个仅用于封装继承过程的函数，该函数内部以某种形式来做增强对象，最后返回对象</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function object (o) &#123;</span><br><span class="line">  function F() &#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createAnother (o) &#123;</span><br><span class="line">  var clone = object(o);</span><br><span class="line">  clone.sayHi = function () &#123;</span><br><span class="line">    console.log(&apos;Hi&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  return clone;</span><br><span class="line">&#125;</span><br><span class="line">缺点：</span><br><span class="line">1,和原型链式继承一样，所有子类实例共享父类引用类型。</span><br><span class="line">2,和借用构造函数继承一样，每次创建对象都会创建一次方法</span><br></pre></td></tr></table></figure><p><strong>寄生组合式继承</strong></p><p><code>结合组合式继承和寄生式继承，解决组合式继承调用两次父类构造函数的问题</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function object(o) &#123;</span><br><span class="line">  function F() &#123; &#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function inheritPrototype(SubType, SuperType) &#123;</span><br><span class="line">  var prototype = object(SuperType.prototype);        // 创建对象</span><br><span class="line">  prototype.constructor = SubType;    // 增强对象</span><br><span class="line">  SubType.prototype = prototype;      // 指定对象 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 父类</span><br><span class="line">function SuperType(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = function () &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line">  // 继承父类实例属性</span><br><span class="line">  SuperType.call(this, name);</span><br><span class="line"></span><br><span class="line">  // 子类实例属性</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 继承父类方法</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br></pre></td></tr></table></figure><p><strong>Es6继承</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function object(o) &#123;</span><br><span class="line">  function F() &#123; &#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function inheritPrototype(SubType, SuperType) &#123;</span><br><span class="line">  var prototype = object(SuperType.prototype);        // 创建对象</span><br><span class="line">  prototype.constructor = SubType;    // 增强对象</span><br><span class="line">  SubType.prototype = prototype;      // 指定对象 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 父类</span><br><span class="line">function SuperType(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = function () &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line">  // 继承父类实例属性</span><br><span class="line">  SuperType.call(this, name);</span><br><span class="line"></span><br><span class="line">  // 子类实例属性</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 继承父类方法</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br></pre></td></tr></table></figure><blockquote><p>底层也是用寄生组合式继承实现的</p></blockquote><p><strong>拷贝继承</strong><br><code>把一个对象中的属性和方法复制到另一个</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">浅拷贝</span><br><span class="line"> function shallowCopy(source, target = &#123;&#125;) &#123;</span><br><span class="line">        var key;</span><br><span class="line">        for (key in source) &#123;</span><br><span class="line">            if (source.hasOwnProperty(key)) &#123;        // 意思就是__proto__上面的属性,我不拷贝</span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">深拷贝 </span><br><span class="line">（对象里面嵌套对象才涉及深拷贝）</span><br><span class="line">function deepCopy(source, target = &#123;&#125;) &#123;</span><br><span class="line">        var key;</span><br><span class="line">        for (key in source) &#123;</span><br><span class="line">            if (source.hasOwnProperty(key)) &#123;                         // 意思就是__proto__上面的属性,我不拷贝</span><br><span class="line">                if (typeof(source[key]) === &quot;object&quot;) &#123;               // 如果这一项是object类型,就递归调用deepCopy</span><br><span class="line">                    target[key] = Array.isArray(source[key]) ? [] : &#123;&#125;;</span><br><span class="line">                    deepCopy(source[key], target[key]);</span><br><span class="line">                &#125; else &#123;                                            // 如果不是object类型,就直接赋值拷贝</span><br><span class="line">                    target[key] = source[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p><strong>深拷贝黑科技</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var targetObj = JSON.parse(JSON.stringify(copyObj))</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">1、如果你的对象里有函数,函数无法被拷贝下来</span><br><span class="line">2、无法拷贝copyObj对象原型链上的属性和方法</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Event Loop</title>
    <link href="http://yoursite.com/2018/08/18/Event%20Loop/"/>
    <id>http://yoursite.com/2018/08/18/Event Loop/</id>
    <published>2018-08-18T14:47:30.000Z</published>
    <updated>2019-08-22T13:02:25.944Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JavaScript的事件分两种，宏任务-macro-task-和微任务-micro-task"><a href="#JavaScript的事件分两种，宏任务-macro-task-和微任务-micro-task" class="headerlink" title="JavaScript的事件分两种，宏任务(macro-task)和微任务(micro-task)"></a>JavaScript的事件分两种，宏任务(macro-task)和微任务(micro-task)</h3><ul><li>宏任务：包括整体代码script，setTimeout，setInterval</li><li>微任务：Promise.then(非new Promise)，process.nextTick(node中)</li></ul><blockquote><p>事件的执行顺序，是先执行宏任务，然后执行微任务，这个是基础，任务可以有同步任务和异步任务，同步的进入主线程，异步的进入Event Table并注册函数，异步事件完成后，会将回调函数放入Event Queue中(宏任务和微任务是不同的Event Queue)，同步任务执行完成后，会从Event Queue中读取事件放入主线程执行，回调函数中可能还会包含不同的任务，因此会循环执行上述操作。<br>``</p></blockquote><a id="more"></a><p>setTimeout(() =&gt; {<br>    console.log(‘延时1秒’);<br>},1000)<br>console.log(“开始”)<br>输出：<br>开始<br>延时1秒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`上述代码，setTimeout函数是宏任务，且是异步任务，因此会将函数放入Event Table并注册函数，经过指定时间后，把要执行的任务加入到Event Queue中，等待同步任务console.log(&quot;开始&quot;)执行结束后，读取Event Queue中setTimeout的回调函数执行。`</span><br><span class="line"></span><br><span class="line">上述代码不包含微任务，接下来看包含微任务的代码：</span><br></pre></td></tr></table></figure><p>setTimeout(function() {<br>    console.log(‘setTimeout’);<br>},1000)</p><p>new Promise(function(resolve) {<br>    console.log(‘promise’);<br>}).then(function() {<br>    console.log(‘then’);<br>})</p><p>console.log(‘console’);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">`首先setTimeout，放入Event Table中，1秒后将回调函数放入宏任务的Event Queue中</span><br><span class="line">new Promise 同步代码，立即执行console.log(&apos;promise&apos;),然后看到微任务then，因此将其放入微任务的Event Queue中</span><br><span class="line">接下来执行同步代码console.log(&apos;console&apos;)</span><br><span class="line">主线程的宏任务，已经执行完毕，接下来要执行微任务，因此会执行Promise.then，到此，第一轮事件循环执行完毕</span><br><span class="line">第二轮事件循环开始，先执行宏任务，即setTimeout的回调函数，然后查找是否有微任务，没有，时间循环结束`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 到此做个总结，事件循环，先执行宏任务，其中同步任务立即执行，异步任务，加载到对应的的Event Queue中(setTimeout等加入宏任务的Event Queue，Promise.then加入微任务的Event Queue)，所有同步宏任务执行完毕后，如果发现微任务的Event Queue中有未执行的任务，会先执行其中的任务，这样算是完成了一次事件循环。接下来查看宏任务的Event Queue中是否有未执行的任务，有的话，就开始第二轮事件循环，依此类推。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上述例子只是简单的一层嵌套，接下来看一个稍微复杂了一点点的例子：</span><br></pre></td></tr></table></figure><p>console.log(‘1’);<br>setTimeout(function() {<br>    console.log(‘2’);<br>    process.nextTick(function() {<br>        console.log(‘3’);<br>    })<br>    new Promise(function(resolve) {<br>        console.log(‘4’);<br>        resolve();<br>    }).then(function() {<br>        console.log(‘5’)<br>    })<br>})<br>输出：<br>1<br>2<br>4<br>3<br>5</p><pre><code>`宏任务同步代码console.log(&apos;1&apos;),不多说setTimeout，加入宏任务Event Queue，没有发现微任务，第一轮事件循环走完第二轮事件循环开始，先执行宏任务，从宏任务Event Queue中独取出setTimeout的回调函数同步代码console.log(&apos;2&apos;),发现process.nextTick，加入微任务Event Queuenew Promise，同步执行console.log(&apos;4&apos;),发现then，加入微任务Event Queue宏任务执行完毕，接下来执行微任务，先执行process.nextTick，然后执行Promise.then微任务执行完毕，第二轮事件循环走完，没有发现宏任务，事件循环结束`</code></pre>]]></content>
    
    <summary type="html">
    
      附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
